{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/img/author.jpg","path":"img/author.jpg","modified":0,"renderable":0},{"_id":"source/img/java-memory2.jpg","path":"img/java-memory2.jpg","modified":0,"renderable":0},{"_id":"source/img/java-memory.jpg","path":"img/java-memory.jpg","modified":0,"renderable":0},{"_id":"source/img/java-stack.jpg","path":"img/java-stack.jpg","modified":0,"renderable":0},{"_id":"source/img/java-stack2.jpg","path":"img/java-stack2.jpg","modified":0,"renderable":0},{"_id":"source/img/cpu.jpg","path":"img/cpu.jpg","modified":0,"renderable":0},{"_id":"source/img/eclipse-conf.jpg","path":"img/eclipse-conf.jpg","modified":0,"renderable":0},{"_id":"source/img/memory.jpg","path":"img/memory.jpg","modified":0,"renderable":0},{"_id":"themes/BlueLake/source/apple-touch-icon.png","path":"apple-touch-icon.png","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/css/style-dark.styl","path":"css/style-dark.styl","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/css/highlight-dark.styl","path":"css/highlight-dark.styl","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.eot","path":"iconfont/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.svg","path":"iconfont/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.woff","path":"iconfont/iconfont.woff","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.ttf","path":"iconfont/iconfont.ttf","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/js/toctotop.js","path":"js/toctotop.js","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/js/search.json.js","path":"js/search.json.js","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/img/bg.jpg","path":"img/bg.jpg","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/share/fonts/iconfont.eot","path":"share/fonts/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/share/fonts/iconfont.svg","path":"share/fonts/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/share/fonts/iconfont.ttf","path":"share/fonts/iconfont.ttf","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/share/fonts/iconfont.woff","path":"share/fonts/iconfont.woff","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/share/css/share.styl","path":"share/css/share.styl","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/share/js/social-share.js","path":"share/js/social-share.js","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/share/js/qrcode.js","path":"share/js/qrcode.js","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/img/bg-dark.jpg","path":"img/bg-dark.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/Hello-Hexo.md","hash":"f8540bed866cd437f4e352e2261a9a8d09641cab","modified":1552966861022},{"_id":"source/_posts/hello-world.md","hash":"93fe4aecd3ce7013a18d7db401648708dad106ab","modified":1552900292183},{"_id":"source/_posts/BlueLake主题搭建博客.md","hash":"7c767382e9e70c05af8451d7319ecd1ac38617b1","modified":1552900292183},{"_id":"source/_posts/dubbo微服务微服务框架梳理.md","hash":"0199ef922edba7a652f7dd51724082baee061a4a","modified":1552900292183},{"_id":"source/_posts/JVM原理.md","hash":"53b1ddfff6d5eb53485a8fd8ec6ef95f4add13a0","modified":1552900292183},{"_id":"source/_posts/spring-cloud初步了解.md","hash":"3d79cca13b3683fe0a128624e94a2ee27abe870d","modified":1552900292184},{"_id":"source/_posts/jvm优化.md","hash":"f403f710494cadc668865651b3873c79609a7acc","modified":1552900292183},{"_id":"source/about/index.md","hash":"de17d1004dfca1aff3e920a469b91319d269260f","modified":1552900292184},{"_id":"source/img/author.jpg","hash":"545cd198ba0e5359a82c77c1c8030f8e909dde4e","modified":1552900292184},{"_id":"source/img/java-memory2.jpg","hash":"863ea04e441356616906435801b88ba298f749f7","modified":1552900292187},{"_id":"source/img/java-memory.jpg","hash":"60385605b5e88fd9a0dc45f429ad06c98c17bdc6","modified":1552900292186},{"_id":"source/img/java-stack.jpg","hash":"1f274c71b5aa93940059574fa8cf87379c677757","modified":1552900292187},{"_id":"source/img/java-stack2.jpg","hash":"5f31530393b5f62a824dc15535ac29994fa37ab8","modified":1552900292188},{"_id":"source/img/cpu.jpg","hash":"e3f2a3a314def53be767a0e47a732bd291e938de","modified":1552900292185},{"_id":"source/img/eclipse-conf.jpg","hash":"c20d0f5d5f63f96c96f2ae0a5e0ba71430109871","modified":1552900292185},{"_id":"source/img/memory.jpg","hash":"f44f8a01804b977ea8a25d871604e584b276d555","modified":1552900292188},{"_id":"themes/BlueLake/LICENSE","hash":"3e191ca3f51efc111863c4941051291a696ef43e","modified":1552980036277},{"_id":"themes/BlueLake/README.en.md","hash":"0b3dc33f102cf09f769bd2855dc964ee43f2c0d9","modified":1552980036278},{"_id":"themes/BlueLake/_config.yml","hash":"0097b54e1f71cc50d61391756cce20d0b1c7c19d","modified":1552982774302},{"_id":"themes/BlueLake/README.md","hash":"fb78575f30757ca78091938e44c2b36cd7a7527a","modified":1552980036278},{"_id":"themes/BlueLake/package.json","hash":"e06eea20c64b2821631a49e8902e645bad2c5102","modified":1552980036292},{"_id":"themes/BlueLake/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1552980036263},{"_id":"themes/BlueLake/.git/config","hash":"cb5d8538f60766fe2a079a1894a586d81b258abf","modified":1552980036266},{"_id":"themes/BlueLake/.git/packed-refs","hash":"ecb3f4b75f525d0bbcd05247baf552d664a928f2","modified":1552980036259},{"_id":"themes/BlueLake/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1552980032147},{"_id":"themes/BlueLake/.git/index","hash":"10249c749c57b75899ff98f4a4423dc30fc1a0c2","modified":1552980036306},{"_id":"themes/BlueLake/languages/de-DE.yml","hash":"fb65e491ac2edb93ab2eb2482caddc8d52369b96","modified":1552980036279},{"_id":"themes/BlueLake/languages/en.yml","hash":"d188387dbbb3584d1797256d639b54f4b824a01e","modified":1552980036279},{"_id":"themes/BlueLake/languages/fr-FR.yml","hash":"a28c26d14694f70e2102a2846af670be86a2f3de","modified":1552980036279},{"_id":"themes/BlueLake/languages/ko.yml","hash":"f3f3b9df5cba303ddcb91a2cc6af0218d7d1ffbc","modified":1552980036280},{"_id":"themes/BlueLake/languages/es-ES.yml","hash":"96a3669b4a0e2b2d8a33bad5338f2c319e612299","modified":1552980036279},{"_id":"themes/BlueLake/languages/zh-CN.yml","hash":"41bc8b0d1ffe892ad4d31d2e221d1cab90ad5188","modified":1552980036280},{"_id":"themes/BlueLake/languages/tr.yml","hash":"89a834a6b6616ac7289968cace76e2fbf0335787","modified":1552980036280},{"_id":"themes/BlueLake/languages/zh-TW.yml","hash":"f5c19f3e89e9f8bf254057879de50f27d7eac690","modified":1552980036281},{"_id":"themes/BlueLake/layout/archive.jade","hash":"0497469c869f0ac28f150295dbddf6920e6582c1","modified":1552980036288},{"_id":"themes/BlueLake/layout/category.jade","hash":"384e2e2588ecab3f518f03f11f2b052d3827fad8","modified":1552980036289},{"_id":"themes/BlueLake/layout/index.jade","hash":"ec2a52c8e38c0f164efe591540d39602f82925b1","modified":1552980036290},{"_id":"themes/BlueLake/layout/base.jade","hash":"c829f43f170afaec2d04342ff385747f98d3db4d","modified":1552980036289},{"_id":"themes/BlueLake/layout/page.jade","hash":"7d2a48f6a902605fd6cfc237e3c2f9c02d76492e","modified":1552980036290},{"_id":"themes/BlueLake/layout/post.jade","hash":"fcca4a1bb09cc5b7f1328f5871ef2b5d36abcb49","modified":1552980036290},{"_id":"themes/BlueLake/layout/tag.jade","hash":"835da21846c730f0e3e344dc7e2e59154030b4f7","modified":1552980036291},{"_id":"themes/BlueLake/source/apple-touch-icon.png","hash":"98f0ecbdcdc1a0e8e52f4d786cbc011e5e06fa65","modified":1552980036292},{"_id":"themes/BlueLake/source/favicon.ico","hash":"94e5d25d942bff5479470322454c951f2ddebac6","modified":1552980036295},{"_id":"themes/BlueLake/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1552980032149},{"_id":"themes/BlueLake/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1552980032150},{"_id":"themes/BlueLake/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1552980032151},{"_id":"themes/BlueLake/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1552980032150},{"_id":"themes/BlueLake/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1552980032152},{"_id":"themes/BlueLake/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1552980032153},{"_id":"themes/BlueLake/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1552980032153},{"_id":"themes/BlueLake/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1552980032149},{"_id":"themes/BlueLake/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1552980032152},{"_id":"themes/BlueLake/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1552980032151},{"_id":"themes/BlueLake/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1552980032154},{"_id":"themes/BlueLake/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1552980032145},{"_id":"themes/BlueLake/.git/logs/HEAD","hash":"df7d288d4ef18f035a7eb2b343662eb1a232a5ac","modified":1552980036264},{"_id":"themes/BlueLake/layout/_partial/comments.jade","hash":"ca1bf06561331f072c5d85b5ffafc0721c8c7955","modified":1552980036282},{"_id":"themes/BlueLake/layout/_partial/comment_count.jade","hash":"52e4cacd58d5e0061924189ad75e0c3bf622aa7f","modified":1552980036282},{"_id":"themes/BlueLake/layout/_partial/after_footer.jade","hash":"e8e98c99b8f9e5f260403903b875a2f08bfb2577","modified":1552980036281},{"_id":"themes/BlueLake/layout/_partial/comments_js.jade","hash":"0fc19d10cc500d71bfd28ce89a71f7b847dab649","modified":1552980036282},{"_id":"themes/BlueLake/layout/_partial/footer.jade","hash":"7736811d57583aa792f966ed260fb1e9b5a8e505","modified":1552980036283},{"_id":"themes/BlueLake/layout/_partial/post_nav.jade","hash":"a2d698c84bb6da08195fe870dbd7215f65388d3f","modified":1552980036283},{"_id":"themes/BlueLake/layout/_partial/helpers.jade","hash":"acdf9e2d52ee86c831fa15ce1570930c5779bc78","modified":1552980036283},{"_id":"themes/BlueLake/layout/_partial/paginator.jade","hash":"53f9cb77448e84a98da5eb688e2e12b173c555bb","modified":1552980036283},{"_id":"themes/BlueLake/layout/_partial/search.jade","hash":"1c988c7e1f716036e428ee16b8005a7b1bfb33c7","modified":1552980036284},{"_id":"themes/BlueLake/layout/_partial/totop.jade","hash":"3e4141538285aef2bd019832ba62bafd094c6097","modified":1552980036285},{"_id":"themes/BlueLake/layout/_partial/share.jade","hash":"db5b44e3124558ca9468faea4bc9d27839c951e8","modified":1552980036284},{"_id":"themes/BlueLake/layout/_partial/tag.jade","hash":"0f0e6770e9d5dd8040e330d71bbbfadd2df36a28","modified":1552980036285},{"_id":"themes/BlueLake/layout/_widget/archive.jade","hash":"082ae16dad18ada28913772675861d7230134bea","modified":1552980036286},{"_id":"themes/BlueLake/layout/_widget/links.jade","hash":"ff46afdedc1ab3c075ffed686b98f23aed066124","modified":1552980036286},{"_id":"themes/BlueLake/layout/_widget/recent_comments.jade","hash":"f8ae55d5514fe493651ec04fbe73cb5fc482f7cd","modified":1552980036287},{"_id":"themes/BlueLake/layout/_widget/category.jade","hash":"ba43bd011d64cd86fa420677c9000d328f4f6114","modified":1552980036286},{"_id":"themes/BlueLake/layout/_widget/recent_posts.jade","hash":"a0309137277323f2fd61a3c6691e1bc51026f711","modified":1552980036287},{"_id":"themes/BlueLake/layout/_widget/weibo.jade","hash":"53e99461ae7f8efb2a1e78ad3090dd93d18bcd5c","modified":1552980036288},{"_id":"themes/BlueLake/layout/_widget/tag.jade","hash":"3df9a00a21d3bc151026b2d403a99c28fe1ccd13","modified":1552980036287},{"_id":"themes/BlueLake/source/css/style-dark.styl","hash":"3a5e2325e779b5ee588b71479426c5fc3637ab27","modified":1552980036294},{"_id":"themes/BlueLake/source/css/highlight-dark.styl","hash":"e6079d1bfdb68b37b111bccc08e4f7d2be9f5eaa","modified":1552980036293},{"_id":"themes/BlueLake/source/css/highlight.styl","hash":"be9ad73454b7029311caafd8e1faa469a5d4f58d","modified":1552980036293},{"_id":"themes/BlueLake/source/css/style.styl","hash":"ddfe354156da0cba08b1efbaed1388224df2c395","modified":1552980036294},{"_id":"themes/BlueLake/source/iconfont/iconfont.eot","hash":"e664dd848ca65fe3aca4acfc234ff9c18ffd4c33","modified":1552980036296},{"_id":"themes/BlueLake/source/iconfont/iconfont.svg","hash":"2b6a0b21bf63bdf746130117baf432fcb44ad210","modified":1552980036296},{"_id":"themes/BlueLake/source/iconfont/iconfont.woff","hash":"df2bd849134cbd02beb385e5061a30b923c99058","modified":1552980036297},{"_id":"themes/BlueLake/source/iconfont/iconfont.ttf","hash":"5770696cc0d19d9c9479912a5cf54c9dd4ab24c4","modified":1552980036297},{"_id":"themes/BlueLake/source/js/toctotop.js","hash":"ad6386bc746ff375715ca9da17af4716ea86e06a","modified":1552980036302},{"_id":"themes/BlueLake/source/js/totop.js","hash":"5b1131830209c2daaf6fe34c5e39ab7c1059bfa4","modified":1552980036302},{"_id":"themes/BlueLake/source/js/search.json.js","hash":"a0e8dfee9b9845aabd64360d497df7c0767b7235","modified":1552980036301},{"_id":"themes/BlueLake/.git/objects/pack/pack-e0f627c626f85cd588773c3e4f0d3fe37850bee5.idx","hash":"30bfb37fe47dee7a084be333bc640000c6f446b6","modified":1552980036242},{"_id":"themes/BlueLake/.git/refs/heads/master","hash":"5216bcb14b9591fe0978ea595274740970824637","modified":1552980036264},{"_id":"themes/BlueLake/source/img/bg.jpg","hash":"d23d92484e98adcbea7266ebfdfef7fb3fc42ee0","modified":1552980036301},{"_id":"themes/BlueLake/source/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1552980036303},{"_id":"themes/BlueLake/source/share/fonts/iconfont.svg","hash":"f0a1b849868a6bf351ff98dc3924a4e7254eb88b","modified":1552980036304},{"_id":"themes/BlueLake/source/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1552980036304},{"_id":"themes/BlueLake/source/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1552980036304},{"_id":"themes/BlueLake/source/share/css/share.styl","hash":"dea3b7a6adb17969e57e5c3d71876245016be21a","modified":1552980036303},{"_id":"themes/BlueLake/source/share/js/social-share.js","hash":"9bfe34fe7691833e90815c5c862545bde581cf29","modified":1552980036306},{"_id":"themes/BlueLake/source/share/js/qrcode.js","hash":"9caa0d9a9ba4409a3f77540a1b15a7617aeb28e8","modified":1552980036305},{"_id":"themes/BlueLake/source/img/bg-dark.jpg","hash":"0d2c406f1a9b3b74d6defda398239b0113737787","modified":1552980036299},{"_id":"themes/BlueLake/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1552980036262},{"_id":"themes/BlueLake/.git/logs/refs/heads/master","hash":"df7d288d4ef18f035a7eb2b343662eb1a232a5ac","modified":1552980036264},{"_id":"themes/BlueLake/.git/logs/refs/remotes/origin/HEAD","hash":"df7d288d4ef18f035a7eb2b343662eb1a232a5ac","modified":1552980036262},{"_id":"themes/BlueLake/.git/objects/pack/pack-e0f627c626f85cd588773c3e4f0d3fe37850bee5.pack","hash":"4717ec2af20af3408e0e17e3c0f1d9794a30975d","modified":1552980036240},{"_id":"themes/BlueLake/._config.yml.swp","hash":"564bb3db926e4d6a120fa19435d4fd24fe63ea5b","modified":1552982438754}],"Category":[],"Data":[],"Page":[{"title":"about","date":"2018-06-25T06:14:48.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2018-06-25 14:14:48\n---","updated":"2019-03-18T09:11:32.184Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjtf8e1co0004v3b8ajfgz2xj","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Hello World","date":"2015-08-19T08:00:57.000Z","_content":"\n<br>\n<br>\n\n<h2><center>Hello World !</center ></h2>\n\n\n<h3><center>欢迎来到我的博客！</center ></h3>\n","source":"_posts/hello-world.md","raw":"---\n\ntitle: Hello World\ndate: 2015-08-19 16:00:57\n\n---\n\n<br>\n<br>\n\n<h2><center>Hello World !</center ></h2>\n\n\n<h3><center>欢迎来到我的博客！</center ></h3>\n","slug":"hello-world","published":1,"updated":"2019-03-18T09:11:32.183Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtf8e1ci0001v3b8oydl3a98","content":"<p><br><br><br></p>\n<h2><center>Hello World !</center></h2>\n\n\n<h3><center>欢迎来到我的博客！</center></h3>\n","site":{"data":{}},"excerpt":"","more":"<p><br><br><br></p>\n<h2><center>Hello World !</center></h2>\n\n\n<h3><center>欢迎来到我的博客！</center></h3>\n"},{"title":"dubbo微服务微服务框架梳理","date":"2018-07-04T04:14:12.000Z","_content":"","source":"_posts/dubbo微服务微服务框架梳理.md","raw":"---\ntitle: dubbo微服务微服务框架梳理\ndate: 2018-07-04 12:14:12\ntags:\n---\n","slug":"dubbo微服务微服务框架梳理","published":1,"updated":"2019-03-18T09:11:32.183Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtf8e1ck0002v3b85pulz0ra","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"BlueLake主题搭建博客","date":"2015-08-29T10:06:06.000Z","_content":"\n原文地址： http://chaoo.oschina.io/2016/12/29/BlueLake博客主题的详细配置.html\n\n## 开始之前\n\nBlueLake主题写了有一段时间了，经常会有朋友发消息给我问一些配置的问题，这篇博文主要也是为了解决这些问题。主题以简洁轻量自居(实则简陋)，去掉了Jquery和Fancybox,用原生JS实现站内搜索功能和回到顶部效果。这个主题只是一个小小的雏形，期待您来帮助它成长。\n\n在阅读本文之前，假定您已经成功安装了Hexo，并使用 Hexo 提供的命令创建了一个静态博客。Hexo是一个快速、简洁且高效的博客框架。Hexo基于Node.js ，使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。\n\n需要特别注意的是Hexo有两个_config.yml配置文件，一份位于站点根目录下，主要包含 Hexo 站点本身的配置，下文中会称为根_config.yml；另一份位于主题目录下（themes/主题名/_config.yml），这份配置由主题作者提供，主要用于配置主题相关的选项,下文中会称为主题_config.yml。\n\n## 1. 安装\n\n您可以直接到BlueLake发布页下载，然后解压拷贝到themes目录下，修改配置即可。\n不过我还是推荐使用GIT来checkout代码，之后也可以通过git pull来快速更新。\n\n### 1.1 安装主题\n\n在根目录下打开终端窗口：\n`$ git clone https://github.com/chaooo/hexo-theme-BlueLake.git themes/BlueLake`\n\n### 1.2 安装主题渲染器\nBlueLake是基于jade和stylus写的，所以需要安装hexo-renderer-jade和hexo-renderer-stylus来渲染。\n\n```\n$ npm install hexo-renderer-jade@0.3.0 --save\n$ npm install hexo-renderer-stylus --save\n```\n\n### 1.3 启用主题\n打开根_config.yml配置文件，找到theme字段，将其值改为BlueLake(先确认主题文件夹名称是否为BlueLake)。\n\n`theme: BlueLake`\n\n### 1.4 验证\n首先启动 Hexo 本地站点，并开启调试模式：\n\n`$ hexo s --debug`\n\n在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出：INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.\n\n此时即可使用浏览器访问 http://localhost:4000，检查站点是否正确运行。\n\n### 1.5 更新主题\n今后若主题添加了新功能正是您需要的，您可以直接git pull来更新主题。\n\n```\ncd themes/BlueLake\ngit pull\n```\n## 2. 配置\n### 2.1 配置网站头部显示文字\n打开根_config.yml，找到：\n\n```\ntitle: \nsubtitle: \ndescription: \nauthor:\n```\ntitle和subtitle分别是网站主标题和副标题，会显示在网站头部；description在网站界面不会显示，内容会加入网站源码的meta标签中，主要用于SEO；author就填写网站所有者的名字，会在网站底部的Copyright处有所显示。\n\n### 2.2 设置语言\n该主题目前有七种语言：简体中文（zh-CN），繁体中文（zh-TW），英语（en），法语（fr-FR），德语（de-DE），韩语 （ko）,西班牙语（es-ES）；例如选用简体中文，在根_config.yml配置如下：\n\n`language: zh-CN`\n### 2.3 设置菜单\n打开主题_config.yml，找到：\n\n```\nmenu:\n  - page: home\n    directory: .\n    icon: fa-home\n  - page: archive\n    directory: archives/\n    icon: fa-archive\n  # - page: about\n  #   directory: about/\n  #   icon: fa-user\n  - page: rss\n    directory: atom.xml\n    icon: fa-rss\n```\n主题默认是展示四个菜单，即主页home，归档archive，关于about，订阅RSS；about需要手动添加，RSS需要安装插件，若您并不需要，可以直接注释掉。\n\n每个页面底部的footer中联系博主的三个图标分别是邮箱，微博主页链接地址，GitHUb个人页链接地址，直接使用主题_config.yml中about页面的配置，若不需要about页面，只需要如下配置就好：\n\n```\nabout:\n  email: ## 个人邮箱 \n  weibo_url: ## 微博主页链接地址\n  github_url: ## github主页链接地址\n```\n\n#### 2.3.1 添加about页\n此主题默认page页面是关于我页面的布局，在根目录下打开命令行窗口，生成一个关于我页面：\n\n`$ hexo new page 'about'`\n\n打开主题_config.yml，补全关于我页面的详细信息：\n\n```\nabout:\n  photo_url: ## 头像的链接地址\n  email: ## 个人邮箱 \n  weibo_url: ## 微博主页链接地址\n  weibo_name: ## 微博用户名 \n  github_url: ## github主页链接地址\n  github_name: ## github用户名\n```\n当然您也可以自定义重新布局about页面，只需要修改layout/page.jade模板就好。\n\n#### 2.3.2 安装 RSS(订阅) 和 sitemap(网站地图) 插件\n在根目录下打开命令行窗口：\n\n```\n$ npm install hexo-generator-feed --save\n$ npm install hexo-generator-sitemap --save\n$ npm install hexo-generator-baidu-sitemap --save\n```\n添加主题_config.yml配置：\n\n```\nPlugins:\n  hexo-generator-feed\n  hexo-generator-sitemap\n  hexo-generator-baidu-sitemap\nfeed:\n  type: atom\n  path: atom.xml\n  limit: 20\nsitemap:\n  path: sitemap.xml\nbaidusitemap:\n  path: baidusitemap.xml\n```\n### 2.4 添加本地搜索\n默认本地搜索是用原生JS写的，但还需要HEXO插件创建的JSON数据文件配合。安装插件hexo-generator-json-content来创建JSON数据文件：\n\n```\n$ npm install hexo-generator-json-content@2.2.0 --save\n```\n然后在根_config.yml添加配置：\n\n```\njsonContent:\n  meta: false\n  pages: false\n  posts:\n    title: true\n    date: true\n    path: true\n    text: true\n    raw: false\n    content: false\n    slug: false\n    updated: false\n    comments: false\n    link: false\n    permalink: false\n    excerpt: false\n    categories: false\n    tags: true\n```\n最后在主题_config.yml添加配置：\n\n```\nlocal_search: true\n```\n### 2.5 修改站点图标\n站点图标存放在主题的Source目录下，已经默认为您准备了两张图片。您也可以自己设计站点LOGO。\n您需要准备一张ico格式并命名为 favicon.ico ，请将其放入hexo目录的source文件夹，建议大小：32px X 32px。\n\n您需要为苹果设备添加网站徽标，请命名为 apple-touch-icon.png 的图像放入hexo目录的“source”文件夹中，建议大小为：114px X 114px。\n(有很多网站都可以在线生成ico格式的图片。)\n\n### 2.6 添加站点关键字\n请在hexo目录的根_config.yml中添加keywords字段，如：\n\n```\n# Site\ntitle: Hexo\nsubtitle: 副标题\ndescription: 网站简要描述,如：Charles·Zheng's blog.\nkeywords: 网站关键字, key, key1, key2, key3\nauthor: Charles\nlanguage: zh-CN\n```\n### 2.7 其他配置\n主题_config.yml的其他配置\n\nshow_category_count——是否显示分类下的文章数。\nwidgets_on_small_screens——是否在小屏显示侧边栏，若true,则侧边栏挂件将显示在底部。\n\n主题_config.ymlthemes/BlueLake/_config.yml\n\n```\nshow_category_count: true \nwidgets_on_small_screens: true\n```\n## 3.集成第三方服务\n### 3.1 添加评论\n目前主题集成六种第三方评论，分别是多说评论、Disqus评论、来必力评论、友言评论、网易云跟帖评论、畅言评论，多说、网易云跟帖、畅言停止服务了，友言好像也没怎么维护,目前我使用的是来必力。\n\n```\n注册并获得代码。\n若使用多说评论，注册多说后获得short_name。\n若使用Disqus评论，注册Disqus后获得short_name。\n若使用来必力评论，注册来必力,获得data-uid。\n若使用友言评论，注册友言,获得uid。\n若使用网易云跟帖评论，注册网易云跟帖,获得productKey。\n若使用畅言评论，注册畅言，获得appid，appkey。\n```\n配置主题_config.yml：\n\n```\n#Cmments\ncomment:\n  duoshuo: ## duoshuo_shortname\n  disqus: ## disqus_shortname\n  livere: ## 来必力(data-uid)\n  uyan: ## 友言(uid)\n  cloudTie: ## 网易云跟帖(productKey)\n  changyan: ## 畅言需在下方配置两个参数，此处不填。\n    appid: ## 畅言(appid)\n    appkey: ##畅言(appkey)\n```\n### 3.2 百度统计\n登录百度统计，定位到站点的代码获取页面。\n复制//hm.baidu.com/hm.js?后面那串统计脚本id(假设为：8006843039519956000)\n配置主题_config.yml:\n\n```\nbaidu_analytics: 8006843039519956000\n```\n注意： baidu_analytics不是你的百度id或者百度统计id\n如若使用谷歌统计，配置方法与百度统计类似。\n\n### 3.3 卜算子阅读次数统计\n主题_config.ymlthemes/BlueLake/_config.yml\n\n```\nbusuanzi: true\n```\n若设置为true将计算文章的阅读量(Hits)，并显示在文章标题下的小手图标旁。\n\n### 3.4 微博秀\n微博秀挂件的代码放在layout/_widget/weibo.jade下，需要您去微博开放平台获取您自己的微博秀代码来替换。\n\n登录微博开放平台，选择微博秀。\n\n为了与主题风格统一，作如下配置\n\n基础设置：高400px；勾选宽度自适应；颜色选择白色；\n\n样式设置：主字色#333；链接色#40759b；鼠标悬停色#f7f8f8；\n\n模块设置：去掉标题、边框、粉丝的勾选框，只留微博。\n\n复制代码里src=\"\"里引号包裹的内容，替换到layout/_widget/weibo.jade\n\n```\n.widget\n  .widget-title\n    i(class='fa fa-weibo')= ' ' + __('新浪微博')\niframe(width=\"100%\",height=\"400\",class=\"share_self\",frameborder=\"0\",scrolling=\"no\",src=\"http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=400&fansRow=2&ptype=1&speed=0&skin=5&isTitle=0&noborder=0&isWeibo=1&isFans=0&uid=1700139362&verifier=85be6061&colors=d6f3f7,ffffff,333,40759b,f7f8f8&dpc=1\")\n```\n这只是为了和主题的风格统一，当然您也可以自由随意发挥。\n\n注意：最主要是是要把src里uid=和verifier=后面的字段替换为您自己代码里的就好。","source":"_posts/BlueLake主题搭建博客.md","raw":"---\n\ntitle: BlueLake主题搭建博客\ndate: 2015-08-29 18:06:06\ntags: \n - BlueLake \n - 博客主题 \n - blogTheme\n \n---\n\n原文地址： http://chaoo.oschina.io/2016/12/29/BlueLake博客主题的详细配置.html\n\n## 开始之前\n\nBlueLake主题写了有一段时间了，经常会有朋友发消息给我问一些配置的问题，这篇博文主要也是为了解决这些问题。主题以简洁轻量自居(实则简陋)，去掉了Jquery和Fancybox,用原生JS实现站内搜索功能和回到顶部效果。这个主题只是一个小小的雏形，期待您来帮助它成长。\n\n在阅读本文之前，假定您已经成功安装了Hexo，并使用 Hexo 提供的命令创建了一个静态博客。Hexo是一个快速、简洁且高效的博客框架。Hexo基于Node.js ，使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。\n\n需要特别注意的是Hexo有两个_config.yml配置文件，一份位于站点根目录下，主要包含 Hexo 站点本身的配置，下文中会称为根_config.yml；另一份位于主题目录下（themes/主题名/_config.yml），这份配置由主题作者提供，主要用于配置主题相关的选项,下文中会称为主题_config.yml。\n\n## 1. 安装\n\n您可以直接到BlueLake发布页下载，然后解压拷贝到themes目录下，修改配置即可。\n不过我还是推荐使用GIT来checkout代码，之后也可以通过git pull来快速更新。\n\n### 1.1 安装主题\n\n在根目录下打开终端窗口：\n`$ git clone https://github.com/chaooo/hexo-theme-BlueLake.git themes/BlueLake`\n\n### 1.2 安装主题渲染器\nBlueLake是基于jade和stylus写的，所以需要安装hexo-renderer-jade和hexo-renderer-stylus来渲染。\n\n```\n$ npm install hexo-renderer-jade@0.3.0 --save\n$ npm install hexo-renderer-stylus --save\n```\n\n### 1.3 启用主题\n打开根_config.yml配置文件，找到theme字段，将其值改为BlueLake(先确认主题文件夹名称是否为BlueLake)。\n\n`theme: BlueLake`\n\n### 1.4 验证\n首先启动 Hexo 本地站点，并开启调试模式：\n\n`$ hexo s --debug`\n\n在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出：INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.\n\n此时即可使用浏览器访问 http://localhost:4000，检查站点是否正确运行。\n\n### 1.5 更新主题\n今后若主题添加了新功能正是您需要的，您可以直接git pull来更新主题。\n\n```\ncd themes/BlueLake\ngit pull\n```\n## 2. 配置\n### 2.1 配置网站头部显示文字\n打开根_config.yml，找到：\n\n```\ntitle: \nsubtitle: \ndescription: \nauthor:\n```\ntitle和subtitle分别是网站主标题和副标题，会显示在网站头部；description在网站界面不会显示，内容会加入网站源码的meta标签中，主要用于SEO；author就填写网站所有者的名字，会在网站底部的Copyright处有所显示。\n\n### 2.2 设置语言\n该主题目前有七种语言：简体中文（zh-CN），繁体中文（zh-TW），英语（en），法语（fr-FR），德语（de-DE），韩语 （ko）,西班牙语（es-ES）；例如选用简体中文，在根_config.yml配置如下：\n\n`language: zh-CN`\n### 2.3 设置菜单\n打开主题_config.yml，找到：\n\n```\nmenu:\n  - page: home\n    directory: .\n    icon: fa-home\n  - page: archive\n    directory: archives/\n    icon: fa-archive\n  # - page: about\n  #   directory: about/\n  #   icon: fa-user\n  - page: rss\n    directory: atom.xml\n    icon: fa-rss\n```\n主题默认是展示四个菜单，即主页home，归档archive，关于about，订阅RSS；about需要手动添加，RSS需要安装插件，若您并不需要，可以直接注释掉。\n\n每个页面底部的footer中联系博主的三个图标分别是邮箱，微博主页链接地址，GitHUb个人页链接地址，直接使用主题_config.yml中about页面的配置，若不需要about页面，只需要如下配置就好：\n\n```\nabout:\n  email: ## 个人邮箱 \n  weibo_url: ## 微博主页链接地址\n  github_url: ## github主页链接地址\n```\n\n#### 2.3.1 添加about页\n此主题默认page页面是关于我页面的布局，在根目录下打开命令行窗口，生成一个关于我页面：\n\n`$ hexo new page 'about'`\n\n打开主题_config.yml，补全关于我页面的详细信息：\n\n```\nabout:\n  photo_url: ## 头像的链接地址\n  email: ## 个人邮箱 \n  weibo_url: ## 微博主页链接地址\n  weibo_name: ## 微博用户名 \n  github_url: ## github主页链接地址\n  github_name: ## github用户名\n```\n当然您也可以自定义重新布局about页面，只需要修改layout/page.jade模板就好。\n\n#### 2.3.2 安装 RSS(订阅) 和 sitemap(网站地图) 插件\n在根目录下打开命令行窗口：\n\n```\n$ npm install hexo-generator-feed --save\n$ npm install hexo-generator-sitemap --save\n$ npm install hexo-generator-baidu-sitemap --save\n```\n添加主题_config.yml配置：\n\n```\nPlugins:\n  hexo-generator-feed\n  hexo-generator-sitemap\n  hexo-generator-baidu-sitemap\nfeed:\n  type: atom\n  path: atom.xml\n  limit: 20\nsitemap:\n  path: sitemap.xml\nbaidusitemap:\n  path: baidusitemap.xml\n```\n### 2.4 添加本地搜索\n默认本地搜索是用原生JS写的，但还需要HEXO插件创建的JSON数据文件配合。安装插件hexo-generator-json-content来创建JSON数据文件：\n\n```\n$ npm install hexo-generator-json-content@2.2.0 --save\n```\n然后在根_config.yml添加配置：\n\n```\njsonContent:\n  meta: false\n  pages: false\n  posts:\n    title: true\n    date: true\n    path: true\n    text: true\n    raw: false\n    content: false\n    slug: false\n    updated: false\n    comments: false\n    link: false\n    permalink: false\n    excerpt: false\n    categories: false\n    tags: true\n```\n最后在主题_config.yml添加配置：\n\n```\nlocal_search: true\n```\n### 2.5 修改站点图标\n站点图标存放在主题的Source目录下，已经默认为您准备了两张图片。您也可以自己设计站点LOGO。\n您需要准备一张ico格式并命名为 favicon.ico ，请将其放入hexo目录的source文件夹，建议大小：32px X 32px。\n\n您需要为苹果设备添加网站徽标，请命名为 apple-touch-icon.png 的图像放入hexo目录的“source”文件夹中，建议大小为：114px X 114px。\n(有很多网站都可以在线生成ico格式的图片。)\n\n### 2.6 添加站点关键字\n请在hexo目录的根_config.yml中添加keywords字段，如：\n\n```\n# Site\ntitle: Hexo\nsubtitle: 副标题\ndescription: 网站简要描述,如：Charles·Zheng's blog.\nkeywords: 网站关键字, key, key1, key2, key3\nauthor: Charles\nlanguage: zh-CN\n```\n### 2.7 其他配置\n主题_config.yml的其他配置\n\nshow_category_count——是否显示分类下的文章数。\nwidgets_on_small_screens——是否在小屏显示侧边栏，若true,则侧边栏挂件将显示在底部。\n\n主题_config.ymlthemes/BlueLake/_config.yml\n\n```\nshow_category_count: true \nwidgets_on_small_screens: true\n```\n## 3.集成第三方服务\n### 3.1 添加评论\n目前主题集成六种第三方评论，分别是多说评论、Disqus评论、来必力评论、友言评论、网易云跟帖评论、畅言评论，多说、网易云跟帖、畅言停止服务了，友言好像也没怎么维护,目前我使用的是来必力。\n\n```\n注册并获得代码。\n若使用多说评论，注册多说后获得short_name。\n若使用Disqus评论，注册Disqus后获得short_name。\n若使用来必力评论，注册来必力,获得data-uid。\n若使用友言评论，注册友言,获得uid。\n若使用网易云跟帖评论，注册网易云跟帖,获得productKey。\n若使用畅言评论，注册畅言，获得appid，appkey。\n```\n配置主题_config.yml：\n\n```\n#Cmments\ncomment:\n  duoshuo: ## duoshuo_shortname\n  disqus: ## disqus_shortname\n  livere: ## 来必力(data-uid)\n  uyan: ## 友言(uid)\n  cloudTie: ## 网易云跟帖(productKey)\n  changyan: ## 畅言需在下方配置两个参数，此处不填。\n    appid: ## 畅言(appid)\n    appkey: ##畅言(appkey)\n```\n### 3.2 百度统计\n登录百度统计，定位到站点的代码获取页面。\n复制//hm.baidu.com/hm.js?后面那串统计脚本id(假设为：8006843039519956000)\n配置主题_config.yml:\n\n```\nbaidu_analytics: 8006843039519956000\n```\n注意： baidu_analytics不是你的百度id或者百度统计id\n如若使用谷歌统计，配置方法与百度统计类似。\n\n### 3.3 卜算子阅读次数统计\n主题_config.ymlthemes/BlueLake/_config.yml\n\n```\nbusuanzi: true\n```\n若设置为true将计算文章的阅读量(Hits)，并显示在文章标题下的小手图标旁。\n\n### 3.4 微博秀\n微博秀挂件的代码放在layout/_widget/weibo.jade下，需要您去微博开放平台获取您自己的微博秀代码来替换。\n\n登录微博开放平台，选择微博秀。\n\n为了与主题风格统一，作如下配置\n\n基础设置：高400px；勾选宽度自适应；颜色选择白色；\n\n样式设置：主字色#333；链接色#40759b；鼠标悬停色#f7f8f8；\n\n模块设置：去掉标题、边框、粉丝的勾选框，只留微博。\n\n复制代码里src=\"\"里引号包裹的内容，替换到layout/_widget/weibo.jade\n\n```\n.widget\n  .widget-title\n    i(class='fa fa-weibo')= ' ' + __('新浪微博')\niframe(width=\"100%\",height=\"400\",class=\"share_self\",frameborder=\"0\",scrolling=\"no\",src=\"http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=400&fansRow=2&ptype=1&speed=0&skin=5&isTitle=0&noborder=0&isWeibo=1&isFans=0&uid=1700139362&verifier=85be6061&colors=d6f3f7,ffffff,333,40759b,f7f8f8&dpc=1\")\n```\n这只是为了和主题的风格统一，当然您也可以自由随意发挥。\n\n注意：最主要是是要把src里uid=和verifier=后面的字段替换为您自己代码里的就好。","slug":"BlueLake主题搭建博客","published":1,"updated":"2019-03-18T09:11:32.183Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtf8e1cn0003v3b8re7tnbvd","content":"<p>原文地址： <a href=\"http://chaoo.oschina.io/2016/12/29/BlueLake博客主题的详细配置.html\" target=\"_blank\" rel=\"noopener\">http://chaoo.oschina.io/2016/12/29/BlueLake博客主题的详细配置.html</a></p>\n<h2 id=\"开始之前\"><a href=\"#开始之前\" class=\"headerlink\" title=\"开始之前\"></a>开始之前</h2><p>BlueLake主题写了有一段时间了，经常会有朋友发消息给我问一些配置的问题，这篇博文主要也是为了解决这些问题。主题以简洁轻量自居(实则简陋)，去掉了Jquery和Fancybox,用原生JS实现站内搜索功能和回到顶部效果。这个主题只是一个小小的雏形，期待您来帮助它成长。</p>\n<p>在阅读本文之前，假定您已经成功安装了Hexo，并使用 Hexo 提供的命令创建了一个静态博客。Hexo是一个快速、简洁且高效的博客框架。Hexo基于Node.js ，使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>\n<p>需要特别注意的是Hexo有两个_config.yml配置文件，一份位于站点根目录下，主要包含 Hexo 站点本身的配置，下文中会称为根_config.yml；另一份位于主题目录下（themes/主题名/_config.yml），这份配置由主题作者提供，主要用于配置主题相关的选项,下文中会称为主题_config.yml。</p>\n<h2 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h2><p>您可以直接到BlueLake发布页下载，然后解压拷贝到themes目录下，修改配置即可。<br>不过我还是推荐使用GIT来checkout代码，之后也可以通过git pull来快速更新。</p>\n<h3 id=\"1-1-安装主题\"><a href=\"#1-1-安装主题\" class=\"headerlink\" title=\"1.1 安装主题\"></a>1.1 安装主题</h3><p>在根目录下打开终端窗口：<br><code>$ git clone https://github.com/chaooo/hexo-theme-BlueLake.git themes/BlueLake</code></p>\n<h3 id=\"1-2-安装主题渲染器\"><a href=\"#1-2-安装主题渲染器\" class=\"headerlink\" title=\"1.2 安装主题渲染器\"></a>1.2 安装主题渲染器</h3><p>BlueLake是基于jade和stylus写的，所以需要安装hexo-renderer-jade和hexo-renderer-stylus来渲染。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-renderer-jade@0.3.0 --save</span><br><span class=\"line\">$ npm install hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-3-启用主题\"><a href=\"#1-3-启用主题\" class=\"headerlink\" title=\"1.3 启用主题\"></a>1.3 启用主题</h3><p>打开根_config.yml配置文件，找到theme字段，将其值改为BlueLake(先确认主题文件夹名称是否为BlueLake)。</p>\n<p><code>theme: BlueLake</code></p>\n<h3 id=\"1-4-验证\"><a href=\"#1-4-验证\" class=\"headerlink\" title=\"1.4 验证\"></a>1.4 验证</h3><p>首先启动 Hexo 本地站点，并开启调试模式：</p>\n<p><code>$ hexo s --debug</code></p>\n<p>在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出：INFO Hexo is running at <a href=\"http://0.0.0.0:4000/\" target=\"_blank\" rel=\"noopener\">http://0.0.0.0:4000/</a>. Press Ctrl+C to stop.</p>\n<p>此时即可使用浏览器访问 <a href=\"http://localhost:4000，检查站点是否正确运行。\" target=\"_blank\" rel=\"noopener\">http://localhost:4000，检查站点是否正确运行。</a></p>\n<h3 id=\"1-5-更新主题\"><a href=\"#1-5-更新主题\" class=\"headerlink\" title=\"1.5 更新主题\"></a>1.5 更新主题</h3><p>今后若主题添加了新功能正是您需要的，您可以直接git pull来更新主题。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd themes/BlueLake</span><br><span class=\"line\">git pull</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-配置\"><a href=\"#2-配置\" class=\"headerlink\" title=\"2. 配置\"></a>2. 配置</h2><h3 id=\"2-1-配置网站头部显示文字\"><a href=\"#2-1-配置网站头部显示文字\" class=\"headerlink\" title=\"2.1 配置网站头部显示文字\"></a>2.1 配置网站头部显示文字</h3><p>打开根_config.yml，找到：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: </span><br><span class=\"line\">subtitle: </span><br><span class=\"line\">description: </span><br><span class=\"line\">author:</span><br></pre></td></tr></table></figure>\n<p>title和subtitle分别是网站主标题和副标题，会显示在网站头部；description在网站界面不会显示，内容会加入网站源码的meta标签中，主要用于SEO；author就填写网站所有者的名字，会在网站底部的Copyright处有所显示。</p>\n<h3 id=\"2-2-设置语言\"><a href=\"#2-2-设置语言\" class=\"headerlink\" title=\"2.2 设置语言\"></a>2.2 设置语言</h3><p>该主题目前有七种语言：简体中文（zh-CN），繁体中文（zh-TW），英语（en），法语（fr-FR），德语（de-DE），韩语 （ko）,西班牙语（es-ES）；例如选用简体中文，在根_config.yml配置如下：</p>\n<p><code>language: zh-CN</code></p>\n<h3 id=\"2-3-设置菜单\"><a href=\"#2-3-设置菜单\" class=\"headerlink\" title=\"2.3 设置菜单\"></a>2.3 设置菜单</h3><p>打开主题_config.yml，找到：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">menu:</span><br><span class=\"line\">  - page: home</span><br><span class=\"line\">    directory: .</span><br><span class=\"line\">    icon: fa-home</span><br><span class=\"line\">  - page: archive</span><br><span class=\"line\">    directory: archives/</span><br><span class=\"line\">    icon: fa-archive</span><br><span class=\"line\">  # - page: about</span><br><span class=\"line\">  #   directory: about/</span><br><span class=\"line\">  #   icon: fa-user</span><br><span class=\"line\">  - page: rss</span><br><span class=\"line\">    directory: atom.xml</span><br><span class=\"line\">    icon: fa-rss</span><br></pre></td></tr></table></figure>\n<p>主题默认是展示四个菜单，即主页home，归档archive，关于about，订阅RSS；about需要手动添加，RSS需要安装插件，若您并不需要，可以直接注释掉。</p>\n<p>每个页面底部的footer中联系博主的三个图标分别是邮箱，微博主页链接地址，GitHUb个人页链接地址，直接使用主题_config.yml中about页面的配置，若不需要about页面，只需要如下配置就好：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">about:</span><br><span class=\"line\">  email: ## 个人邮箱 </span><br><span class=\"line\">  weibo_url: ## 微博主页链接地址</span><br><span class=\"line\">  github_url: ## github主页链接地址</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-3-1-添加about页\"><a href=\"#2-3-1-添加about页\" class=\"headerlink\" title=\"2.3.1 添加about页\"></a>2.3.1 添加about页</h4><p>此主题默认page页面是关于我页面的布局，在根目录下打开命令行窗口，生成一个关于我页面：</p>\n<p><code>$ hexo new page &#39;about&#39;</code></p>\n<p>打开主题_config.yml，补全关于我页面的详细信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">about:</span><br><span class=\"line\">  photo_url: ## 头像的链接地址</span><br><span class=\"line\">  email: ## 个人邮箱 </span><br><span class=\"line\">  weibo_url: ## 微博主页链接地址</span><br><span class=\"line\">  weibo_name: ## 微博用户名 </span><br><span class=\"line\">  github_url: ## github主页链接地址</span><br><span class=\"line\">  github_name: ## github用户名</span><br></pre></td></tr></table></figure>\n<p>当然您也可以自定义重新布局about页面，只需要修改layout/page.jade模板就好。</p>\n<h4 id=\"2-3-2-安装-RSS-订阅-和-sitemap-网站地图-插件\"><a href=\"#2-3-2-安装-RSS-订阅-和-sitemap-网站地图-插件\" class=\"headerlink\" title=\"2.3.2 安装 RSS(订阅) 和 sitemap(网站地图) 插件\"></a>2.3.2 安装 RSS(订阅) 和 sitemap(网站地图) 插件</h4><p>在根目录下打开命令行窗口：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-generator-feed --save</span><br><span class=\"line\">$ npm install hexo-generator-sitemap --save</span><br><span class=\"line\">$ npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure>\n<p>添加主题_config.yml配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Plugins:</span><br><span class=\"line\">  hexo-generator-feed</span><br><span class=\"line\">  hexo-generator-sitemap</span><br><span class=\"line\">  hexo-generator-baidu-sitemap</span><br><span class=\"line\">feed:</span><br><span class=\"line\">  type: atom</span><br><span class=\"line\">  path: atom.xml</span><br><span class=\"line\">  limit: 20</span><br><span class=\"line\">sitemap:</span><br><span class=\"line\">  path: sitemap.xml</span><br><span class=\"line\">baidusitemap:</span><br><span class=\"line\">  path: baidusitemap.xml</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-4-添加本地搜索\"><a href=\"#2-4-添加本地搜索\" class=\"headerlink\" title=\"2.4 添加本地搜索\"></a>2.4 添加本地搜索</h3><p>默认本地搜索是用原生JS写的，但还需要HEXO插件创建的JSON数据文件配合。安装插件hexo-generator-json-content来创建JSON数据文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-generator-json-content@2.2.0 --save</span><br></pre></td></tr></table></figure>\n<p>然后在根_config.yml添加配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jsonContent:</span><br><span class=\"line\">  meta: false</span><br><span class=\"line\">  pages: false</span><br><span class=\"line\">  posts:</span><br><span class=\"line\">    title: true</span><br><span class=\"line\">    date: true</span><br><span class=\"line\">    path: true</span><br><span class=\"line\">    text: true</span><br><span class=\"line\">    raw: false</span><br><span class=\"line\">    content: false</span><br><span class=\"line\">    slug: false</span><br><span class=\"line\">    updated: false</span><br><span class=\"line\">    comments: false</span><br><span class=\"line\">    link: false</span><br><span class=\"line\">    permalink: false</span><br><span class=\"line\">    excerpt: false</span><br><span class=\"line\">    categories: false</span><br><span class=\"line\">    tags: true</span><br></pre></td></tr></table></figure>\n<p>最后在主题_config.yml添加配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">local_search: true</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-5-修改站点图标\"><a href=\"#2-5-修改站点图标\" class=\"headerlink\" title=\"2.5 修改站点图标\"></a>2.5 修改站点图标</h3><p>站点图标存放在主题的Source目录下，已经默认为您准备了两张图片。您也可以自己设计站点LOGO。<br>您需要准备一张ico格式并命名为 favicon.ico ，请将其放入hexo目录的source文件夹，建议大小：32px X 32px。</p>\n<p>您需要为苹果设备添加网站徽标，请命名为 apple-touch-icon.png 的图像放入hexo目录的“source”文件夹中，建议大小为：114px X 114px。<br>(有很多网站都可以在线生成ico格式的图片。)</p>\n<h3 id=\"2-6-添加站点关键字\"><a href=\"#2-6-添加站点关键字\" class=\"headerlink\" title=\"2.6 添加站点关键字\"></a>2.6 添加站点关键字</h3><p>请在hexo目录的根_config.yml中添加keywords字段，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Site</span><br><span class=\"line\">title: Hexo</span><br><span class=\"line\">subtitle: 副标题</span><br><span class=\"line\">description: 网站简要描述,如：Charles·Zheng&apos;s blog.</span><br><span class=\"line\">keywords: 网站关键字, key, key1, key2, key3</span><br><span class=\"line\">author: Charles</span><br><span class=\"line\">language: zh-CN</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-7-其他配置\"><a href=\"#2-7-其他配置\" class=\"headerlink\" title=\"2.7 其他配置\"></a>2.7 其他配置</h3><p>主题_config.yml的其他配置</p>\n<p>show_category_count——是否显示分类下的文章数。<br>widgets_on_small_screens——是否在小屏显示侧边栏，若true,则侧边栏挂件将显示在底部。</p>\n<p>主题_config.ymlthemes/BlueLake/_config.yml</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show_category_count: true </span><br><span class=\"line\">widgets_on_small_screens: true</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-集成第三方服务\"><a href=\"#3-集成第三方服务\" class=\"headerlink\" title=\"3.集成第三方服务\"></a>3.集成第三方服务</h2><h3 id=\"3-1-添加评论\"><a href=\"#3-1-添加评论\" class=\"headerlink\" title=\"3.1 添加评论\"></a>3.1 添加评论</h3><p>目前主题集成六种第三方评论，分别是多说评论、Disqus评论、来必力评论、友言评论、网易云跟帖评论、畅言评论，多说、网易云跟帖、畅言停止服务了，友言好像也没怎么维护,目前我使用的是来必力。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">注册并获得代码。</span><br><span class=\"line\">若使用多说评论，注册多说后获得short_name。</span><br><span class=\"line\">若使用Disqus评论，注册Disqus后获得short_name。</span><br><span class=\"line\">若使用来必力评论，注册来必力,获得data-uid。</span><br><span class=\"line\">若使用友言评论，注册友言,获得uid。</span><br><span class=\"line\">若使用网易云跟帖评论，注册网易云跟帖,获得productKey。</span><br><span class=\"line\">若使用畅言评论，注册畅言，获得appid，appkey。</span><br></pre></td></tr></table></figure>\n<p>配置主题_config.yml：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#Cmments</span><br><span class=\"line\">comment:</span><br><span class=\"line\">  duoshuo: ## duoshuo_shortname</span><br><span class=\"line\">  disqus: ## disqus_shortname</span><br><span class=\"line\">  livere: ## 来必力(data-uid)</span><br><span class=\"line\">  uyan: ## 友言(uid)</span><br><span class=\"line\">  cloudTie: ## 网易云跟帖(productKey)</span><br><span class=\"line\">  changyan: ## 畅言需在下方配置两个参数，此处不填。</span><br><span class=\"line\">    appid: ## 畅言(appid)</span><br><span class=\"line\">    appkey: ##畅言(appkey)</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-2-百度统计\"><a href=\"#3-2-百度统计\" class=\"headerlink\" title=\"3.2 百度统计\"></a>3.2 百度统计</h3><p>登录百度统计，定位到站点的代码获取页面。<br>复制//hm.baidu.com/hm.js?后面那串统计脚本id(假设为：8006843039519956000)<br>配置主题_config.yml:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">baidu_analytics: 8006843039519956000</span><br></pre></td></tr></table></figure>\n<p>注意： baidu_analytics不是你的百度id或者百度统计id<br>如若使用谷歌统计，配置方法与百度统计类似。</p>\n<h3 id=\"3-3-卜算子阅读次数统计\"><a href=\"#3-3-卜算子阅读次数统计\" class=\"headerlink\" title=\"3.3 卜算子阅读次数统计\"></a>3.3 卜算子阅读次数统计</h3><p>主题_config.ymlthemes/BlueLake/_config.yml</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">busuanzi: true</span><br></pre></td></tr></table></figure>\n<p>若设置为true将计算文章的阅读量(Hits)，并显示在文章标题下的小手图标旁。</p>\n<h3 id=\"3-4-微博秀\"><a href=\"#3-4-微博秀\" class=\"headerlink\" title=\"3.4 微博秀\"></a>3.4 微博秀</h3><p>微博秀挂件的代码放在layout/_widget/weibo.jade下，需要您去微博开放平台获取您自己的微博秀代码来替换。</p>\n<p>登录微博开放平台，选择微博秀。</p>\n<p>为了与主题风格统一，作如下配置</p>\n<p>基础设置：高400px；勾选宽度自适应；颜色选择白色；</p>\n<p>样式设置：主字色#333；链接色#40759b；鼠标悬停色#f7f8f8；</p>\n<p>模块设置：去掉标题、边框、粉丝的勾选框，只留微博。</p>\n<p>复制代码里src=””里引号包裹的内容，替换到layout/_widget/weibo.jade</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.widget</span><br><span class=\"line\">  .widget-title</span><br><span class=\"line\">    i(class=&apos;fa fa-weibo&apos;)= &apos; &apos; + __(&apos;新浪微博&apos;)</span><br><span class=\"line\">iframe(width=&quot;100%&quot;,height=&quot;400&quot;,class=&quot;share_self&quot;,frameborder=&quot;0&quot;,scrolling=&quot;no&quot;,src=&quot;http://widget.weibo.com/weiboshow/index.php?language=&amp;width=0&amp;height=400&amp;fansRow=2&amp;ptype=1&amp;speed=0&amp;skin=5&amp;isTitle=0&amp;noborder=0&amp;isWeibo=1&amp;isFans=0&amp;uid=1700139362&amp;verifier=85be6061&amp;colors=d6f3f7,ffffff,333,40759b,f7f8f8&amp;dpc=1&quot;)</span><br></pre></td></tr></table></figure>\n<p>这只是为了和主题的风格统一，当然您也可以自由随意发挥。</p>\n<p>注意：最主要是是要把src里uid=和verifier=后面的字段替换为您自己代码里的就好。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>原文地址： <a href=\"http://chaoo.oschina.io/2016/12/29/BlueLake博客主题的详细配置.html\" target=\"_blank\" rel=\"noopener\">http://chaoo.oschina.io/2016/12/29/BlueLake博客主题的详细配置.html</a></p>\n<h2 id=\"开始之前\"><a href=\"#开始之前\" class=\"headerlink\" title=\"开始之前\"></a>开始之前</h2><p>BlueLake主题写了有一段时间了，经常会有朋友发消息给我问一些配置的问题，这篇博文主要也是为了解决这些问题。主题以简洁轻量自居(实则简陋)，去掉了Jquery和Fancybox,用原生JS实现站内搜索功能和回到顶部效果。这个主题只是一个小小的雏形，期待您来帮助它成长。</p>\n<p>在阅读本文之前，假定您已经成功安装了Hexo，并使用 Hexo 提供的命令创建了一个静态博客。Hexo是一个快速、简洁且高效的博客框架。Hexo基于Node.js ，使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>\n<p>需要特别注意的是Hexo有两个_config.yml配置文件，一份位于站点根目录下，主要包含 Hexo 站点本身的配置，下文中会称为根_config.yml；另一份位于主题目录下（themes/主题名/_config.yml），这份配置由主题作者提供，主要用于配置主题相关的选项,下文中会称为主题_config.yml。</p>\n<h2 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h2><p>您可以直接到BlueLake发布页下载，然后解压拷贝到themes目录下，修改配置即可。<br>不过我还是推荐使用GIT来checkout代码，之后也可以通过git pull来快速更新。</p>\n<h3 id=\"1-1-安装主题\"><a href=\"#1-1-安装主题\" class=\"headerlink\" title=\"1.1 安装主题\"></a>1.1 安装主题</h3><p>在根目录下打开终端窗口：<br><code>$ git clone https://github.com/chaooo/hexo-theme-BlueLake.git themes/BlueLake</code></p>\n<h3 id=\"1-2-安装主题渲染器\"><a href=\"#1-2-安装主题渲染器\" class=\"headerlink\" title=\"1.2 安装主题渲染器\"></a>1.2 安装主题渲染器</h3><p>BlueLake是基于jade和stylus写的，所以需要安装hexo-renderer-jade和hexo-renderer-stylus来渲染。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-renderer-jade@0.3.0 --save</span><br><span class=\"line\">$ npm install hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-3-启用主题\"><a href=\"#1-3-启用主题\" class=\"headerlink\" title=\"1.3 启用主题\"></a>1.3 启用主题</h3><p>打开根_config.yml配置文件，找到theme字段，将其值改为BlueLake(先确认主题文件夹名称是否为BlueLake)。</p>\n<p><code>theme: BlueLake</code></p>\n<h3 id=\"1-4-验证\"><a href=\"#1-4-验证\" class=\"headerlink\" title=\"1.4 验证\"></a>1.4 验证</h3><p>首先启动 Hexo 本地站点，并开启调试模式：</p>\n<p><code>$ hexo s --debug</code></p>\n<p>在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出：INFO Hexo is running at <a href=\"http://0.0.0.0:4000/\" target=\"_blank\" rel=\"noopener\">http://0.0.0.0:4000/</a>. Press Ctrl+C to stop.</p>\n<p>此时即可使用浏览器访问 <a href=\"http://localhost:4000，检查站点是否正确运行。\" target=\"_blank\" rel=\"noopener\">http://localhost:4000，检查站点是否正确运行。</a></p>\n<h3 id=\"1-5-更新主题\"><a href=\"#1-5-更新主题\" class=\"headerlink\" title=\"1.5 更新主题\"></a>1.5 更新主题</h3><p>今后若主题添加了新功能正是您需要的，您可以直接git pull来更新主题。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd themes/BlueLake</span><br><span class=\"line\">git pull</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-配置\"><a href=\"#2-配置\" class=\"headerlink\" title=\"2. 配置\"></a>2. 配置</h2><h3 id=\"2-1-配置网站头部显示文字\"><a href=\"#2-1-配置网站头部显示文字\" class=\"headerlink\" title=\"2.1 配置网站头部显示文字\"></a>2.1 配置网站头部显示文字</h3><p>打开根_config.yml，找到：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: </span><br><span class=\"line\">subtitle: </span><br><span class=\"line\">description: </span><br><span class=\"line\">author:</span><br></pre></td></tr></table></figure>\n<p>title和subtitle分别是网站主标题和副标题，会显示在网站头部；description在网站界面不会显示，内容会加入网站源码的meta标签中，主要用于SEO；author就填写网站所有者的名字，会在网站底部的Copyright处有所显示。</p>\n<h3 id=\"2-2-设置语言\"><a href=\"#2-2-设置语言\" class=\"headerlink\" title=\"2.2 设置语言\"></a>2.2 设置语言</h3><p>该主题目前有七种语言：简体中文（zh-CN），繁体中文（zh-TW），英语（en），法语（fr-FR），德语（de-DE），韩语 （ko）,西班牙语（es-ES）；例如选用简体中文，在根_config.yml配置如下：</p>\n<p><code>language: zh-CN</code></p>\n<h3 id=\"2-3-设置菜单\"><a href=\"#2-3-设置菜单\" class=\"headerlink\" title=\"2.3 设置菜单\"></a>2.3 设置菜单</h3><p>打开主题_config.yml，找到：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">menu:</span><br><span class=\"line\">  - page: home</span><br><span class=\"line\">    directory: .</span><br><span class=\"line\">    icon: fa-home</span><br><span class=\"line\">  - page: archive</span><br><span class=\"line\">    directory: archives/</span><br><span class=\"line\">    icon: fa-archive</span><br><span class=\"line\">  # - page: about</span><br><span class=\"line\">  #   directory: about/</span><br><span class=\"line\">  #   icon: fa-user</span><br><span class=\"line\">  - page: rss</span><br><span class=\"line\">    directory: atom.xml</span><br><span class=\"line\">    icon: fa-rss</span><br></pre></td></tr></table></figure>\n<p>主题默认是展示四个菜单，即主页home，归档archive，关于about，订阅RSS；about需要手动添加，RSS需要安装插件，若您并不需要，可以直接注释掉。</p>\n<p>每个页面底部的footer中联系博主的三个图标分别是邮箱，微博主页链接地址，GitHUb个人页链接地址，直接使用主题_config.yml中about页面的配置，若不需要about页面，只需要如下配置就好：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">about:</span><br><span class=\"line\">  email: ## 个人邮箱 </span><br><span class=\"line\">  weibo_url: ## 微博主页链接地址</span><br><span class=\"line\">  github_url: ## github主页链接地址</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-3-1-添加about页\"><a href=\"#2-3-1-添加about页\" class=\"headerlink\" title=\"2.3.1 添加about页\"></a>2.3.1 添加about页</h4><p>此主题默认page页面是关于我页面的布局，在根目录下打开命令行窗口，生成一个关于我页面：</p>\n<p><code>$ hexo new page &#39;about&#39;</code></p>\n<p>打开主题_config.yml，补全关于我页面的详细信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">about:</span><br><span class=\"line\">  photo_url: ## 头像的链接地址</span><br><span class=\"line\">  email: ## 个人邮箱 </span><br><span class=\"line\">  weibo_url: ## 微博主页链接地址</span><br><span class=\"line\">  weibo_name: ## 微博用户名 </span><br><span class=\"line\">  github_url: ## github主页链接地址</span><br><span class=\"line\">  github_name: ## github用户名</span><br></pre></td></tr></table></figure>\n<p>当然您也可以自定义重新布局about页面，只需要修改layout/page.jade模板就好。</p>\n<h4 id=\"2-3-2-安装-RSS-订阅-和-sitemap-网站地图-插件\"><a href=\"#2-3-2-安装-RSS-订阅-和-sitemap-网站地图-插件\" class=\"headerlink\" title=\"2.3.2 安装 RSS(订阅) 和 sitemap(网站地图) 插件\"></a>2.3.2 安装 RSS(订阅) 和 sitemap(网站地图) 插件</h4><p>在根目录下打开命令行窗口：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-generator-feed --save</span><br><span class=\"line\">$ npm install hexo-generator-sitemap --save</span><br><span class=\"line\">$ npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure>\n<p>添加主题_config.yml配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Plugins:</span><br><span class=\"line\">  hexo-generator-feed</span><br><span class=\"line\">  hexo-generator-sitemap</span><br><span class=\"line\">  hexo-generator-baidu-sitemap</span><br><span class=\"line\">feed:</span><br><span class=\"line\">  type: atom</span><br><span class=\"line\">  path: atom.xml</span><br><span class=\"line\">  limit: 20</span><br><span class=\"line\">sitemap:</span><br><span class=\"line\">  path: sitemap.xml</span><br><span class=\"line\">baidusitemap:</span><br><span class=\"line\">  path: baidusitemap.xml</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-4-添加本地搜索\"><a href=\"#2-4-添加本地搜索\" class=\"headerlink\" title=\"2.4 添加本地搜索\"></a>2.4 添加本地搜索</h3><p>默认本地搜索是用原生JS写的，但还需要HEXO插件创建的JSON数据文件配合。安装插件hexo-generator-json-content来创建JSON数据文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-generator-json-content@2.2.0 --save</span><br></pre></td></tr></table></figure>\n<p>然后在根_config.yml添加配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jsonContent:</span><br><span class=\"line\">  meta: false</span><br><span class=\"line\">  pages: false</span><br><span class=\"line\">  posts:</span><br><span class=\"line\">    title: true</span><br><span class=\"line\">    date: true</span><br><span class=\"line\">    path: true</span><br><span class=\"line\">    text: true</span><br><span class=\"line\">    raw: false</span><br><span class=\"line\">    content: false</span><br><span class=\"line\">    slug: false</span><br><span class=\"line\">    updated: false</span><br><span class=\"line\">    comments: false</span><br><span class=\"line\">    link: false</span><br><span class=\"line\">    permalink: false</span><br><span class=\"line\">    excerpt: false</span><br><span class=\"line\">    categories: false</span><br><span class=\"line\">    tags: true</span><br></pre></td></tr></table></figure>\n<p>最后在主题_config.yml添加配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">local_search: true</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-5-修改站点图标\"><a href=\"#2-5-修改站点图标\" class=\"headerlink\" title=\"2.5 修改站点图标\"></a>2.5 修改站点图标</h3><p>站点图标存放在主题的Source目录下，已经默认为您准备了两张图片。您也可以自己设计站点LOGO。<br>您需要准备一张ico格式并命名为 favicon.ico ，请将其放入hexo目录的source文件夹，建议大小：32px X 32px。</p>\n<p>您需要为苹果设备添加网站徽标，请命名为 apple-touch-icon.png 的图像放入hexo目录的“source”文件夹中，建议大小为：114px X 114px。<br>(有很多网站都可以在线生成ico格式的图片。)</p>\n<h3 id=\"2-6-添加站点关键字\"><a href=\"#2-6-添加站点关键字\" class=\"headerlink\" title=\"2.6 添加站点关键字\"></a>2.6 添加站点关键字</h3><p>请在hexo目录的根_config.yml中添加keywords字段，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Site</span><br><span class=\"line\">title: Hexo</span><br><span class=\"line\">subtitle: 副标题</span><br><span class=\"line\">description: 网站简要描述,如：Charles·Zheng&apos;s blog.</span><br><span class=\"line\">keywords: 网站关键字, key, key1, key2, key3</span><br><span class=\"line\">author: Charles</span><br><span class=\"line\">language: zh-CN</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-7-其他配置\"><a href=\"#2-7-其他配置\" class=\"headerlink\" title=\"2.7 其他配置\"></a>2.7 其他配置</h3><p>主题_config.yml的其他配置</p>\n<p>show_category_count——是否显示分类下的文章数。<br>widgets_on_small_screens——是否在小屏显示侧边栏，若true,则侧边栏挂件将显示在底部。</p>\n<p>主题_config.ymlthemes/BlueLake/_config.yml</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show_category_count: true </span><br><span class=\"line\">widgets_on_small_screens: true</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-集成第三方服务\"><a href=\"#3-集成第三方服务\" class=\"headerlink\" title=\"3.集成第三方服务\"></a>3.集成第三方服务</h2><h3 id=\"3-1-添加评论\"><a href=\"#3-1-添加评论\" class=\"headerlink\" title=\"3.1 添加评论\"></a>3.1 添加评论</h3><p>目前主题集成六种第三方评论，分别是多说评论、Disqus评论、来必力评论、友言评论、网易云跟帖评论、畅言评论，多说、网易云跟帖、畅言停止服务了，友言好像也没怎么维护,目前我使用的是来必力。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">注册并获得代码。</span><br><span class=\"line\">若使用多说评论，注册多说后获得short_name。</span><br><span class=\"line\">若使用Disqus评论，注册Disqus后获得short_name。</span><br><span class=\"line\">若使用来必力评论，注册来必力,获得data-uid。</span><br><span class=\"line\">若使用友言评论，注册友言,获得uid。</span><br><span class=\"line\">若使用网易云跟帖评论，注册网易云跟帖,获得productKey。</span><br><span class=\"line\">若使用畅言评论，注册畅言，获得appid，appkey。</span><br></pre></td></tr></table></figure>\n<p>配置主题_config.yml：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#Cmments</span><br><span class=\"line\">comment:</span><br><span class=\"line\">  duoshuo: ## duoshuo_shortname</span><br><span class=\"line\">  disqus: ## disqus_shortname</span><br><span class=\"line\">  livere: ## 来必力(data-uid)</span><br><span class=\"line\">  uyan: ## 友言(uid)</span><br><span class=\"line\">  cloudTie: ## 网易云跟帖(productKey)</span><br><span class=\"line\">  changyan: ## 畅言需在下方配置两个参数，此处不填。</span><br><span class=\"line\">    appid: ## 畅言(appid)</span><br><span class=\"line\">    appkey: ##畅言(appkey)</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-2-百度统计\"><a href=\"#3-2-百度统计\" class=\"headerlink\" title=\"3.2 百度统计\"></a>3.2 百度统计</h3><p>登录百度统计，定位到站点的代码获取页面。<br>复制//hm.baidu.com/hm.js?后面那串统计脚本id(假设为：8006843039519956000)<br>配置主题_config.yml:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">baidu_analytics: 8006843039519956000</span><br></pre></td></tr></table></figure>\n<p>注意： baidu_analytics不是你的百度id或者百度统计id<br>如若使用谷歌统计，配置方法与百度统计类似。</p>\n<h3 id=\"3-3-卜算子阅读次数统计\"><a href=\"#3-3-卜算子阅读次数统计\" class=\"headerlink\" title=\"3.3 卜算子阅读次数统计\"></a>3.3 卜算子阅读次数统计</h3><p>主题_config.ymlthemes/BlueLake/_config.yml</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">busuanzi: true</span><br></pre></td></tr></table></figure>\n<p>若设置为true将计算文章的阅读量(Hits)，并显示在文章标题下的小手图标旁。</p>\n<h3 id=\"3-4-微博秀\"><a href=\"#3-4-微博秀\" class=\"headerlink\" title=\"3.4 微博秀\"></a>3.4 微博秀</h3><p>微博秀挂件的代码放在layout/_widget/weibo.jade下，需要您去微博开放平台获取您自己的微博秀代码来替换。</p>\n<p>登录微博开放平台，选择微博秀。</p>\n<p>为了与主题风格统一，作如下配置</p>\n<p>基础设置：高400px；勾选宽度自适应；颜色选择白色；</p>\n<p>样式设置：主字色#333；链接色#40759b；鼠标悬停色#f7f8f8；</p>\n<p>模块设置：去掉标题、边框、粉丝的勾选框，只留微博。</p>\n<p>复制代码里src=””里引号包裹的内容，替换到layout/_widget/weibo.jade</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.widget</span><br><span class=\"line\">  .widget-title</span><br><span class=\"line\">    i(class=&apos;fa fa-weibo&apos;)= &apos; &apos; + __(&apos;新浪微博&apos;)</span><br><span class=\"line\">iframe(width=&quot;100%&quot;,height=&quot;400&quot;,class=&quot;share_self&quot;,frameborder=&quot;0&quot;,scrolling=&quot;no&quot;,src=&quot;http://widget.weibo.com/weiboshow/index.php?language=&amp;width=0&amp;height=400&amp;fansRow=2&amp;ptype=1&amp;speed=0&amp;skin=5&amp;isTitle=0&amp;noborder=0&amp;isWeibo=1&amp;isFans=0&amp;uid=1700139362&amp;verifier=85be6061&amp;colors=d6f3f7,ffffff,333,40759b,f7f8f8&amp;dpc=1&quot;)</span><br></pre></td></tr></table></figure>\n<p>这只是为了和主题的风格统一，当然您也可以自由随意发挥。</p>\n<p>注意：最主要是是要把src里uid=和verifier=后面的字段替换为您自己代码里的就好。</p>\n"},{"title":"spring cloud初步了解","date":"2018-06-29T06:16:04.000Z","_content":"","source":"_posts/spring-cloud初步了解.md","raw":"---\ntitle: spring cloud初步了解\ndate: 2018-06-29 14:16:04\ntags:\n---\n","slug":"spring-cloud初步了解","published":1,"updated":"2019-03-18T09:11:32.184Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtf8e1cp0005v3b8t9nimpmq","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"jvm优化","date":"2017-01-03T06:19:45.000Z","_content":"\n# 常见配置汇总\n## 1.堆设置\n\n\n-Xmx:最大堆内存,如：-Xmx512m\n\n-Xms:初始时堆内存,如：-Xms256m\n\n-XX:MaxNewSize:最大年轻区内存\n\n-XX:NewSize:初始时年轻区内存.通常为 Xmx 的 1/3 或 1/4。新生代 = Eden + 2 个 Survivor 空间。实际可用空间为 = Eden + 1 个 Survivor，即 90%\n\n-XX:MaxPermSize:最大持久带内存\n\n-XX:PermSize:初始时持久带内存\n\n-XX:+PrintGCDetails。打印 GC 信息\n\n -XX:NewRatio 新生代与老年代的比例，如 –XX:NewRatio=2，则新生代占整个堆空间的1/3，老年代占2/3\n\n -XX:SurvivorRatio 新生代中 Eden 与 Survivor 的比值。默认值为 8。即 Eden 占新生代空间的 8/10，另外两个 Survivor 各占 1/10\n\n\n\n\n\n-Xms:初始堆大小，此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。例如：-Xms3550m， 或者-Xms4g\n\n-Xmx:最大堆大小,设置JVM最大可用内存.\n\n-XX:NewSize=n:设置年轻代大小\n\n-XX:NewRatio=n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4\n\n-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5\n\n-XX:MaxPermSize=n:设置持久代大小\n\n## 2.收集器设置\n\n-XX:+UseSerialGC:设置串行收集器\n\n-XX:+UseParallelGC:设置并行收集器\n\n-XX:+UseParalledlOldGC:设置并行年老代收集器\n\n-XX:+UseConcMarkSweepGC:设置并发收集器\n\n## 3.垃圾回收统计信息\n\n-XX:+PrintGC\n\n-XX:+PrintGCDetails\n\n-XX:+PrintGCTimeStamps\n\n-Xloggc:filename\n\n## 4.并行收集器设置\n\n-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。\n\n-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间\n\n-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)\n\n## 5.并发收集器设置\n\n-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。\n\n-XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。\n\n# 调优总结\n## 1.年轻代大小选择\n\n**响应时间优先的应用：** 尽可能设大，直到接近系统的最低响应时间限制（根据实际情况选择）。在此种情况下，年轻代收集发生的频率也是最小的。同时，减少到达年老代的对象。\n\n**吞吐量优先的应用：** 尽可能的设置大，可能到达Gbit的程度。因为对响应时间没有要求，垃圾收集可以并行进行，一般适合8CPU以上的应用。\n\n## 2.年老代大小选择\n\n**响应时间优先的应用：** 年老代使用并发收集器，所以其大小需要小心设置，一般要考虑并发会话率和会话持续时间等一些参数。如果堆设置小了，可以会造成内存碎片、高回收频率以及应用暂停而使用传统的标记清除方式；如果堆大了，则需要较长的收集时间。最优化的方案，一般需要参考以下数据获得：\n\n1. 并发垃圾收集信息\n\n2. 持久代并发收集次数\n\n3. 传统GC信息\n\n4. 花在年轻代和年老代回收上的时间比例\n\n减少年轻代和年老代花费的时间，一般会提高应用的效率\n\n**吞吐量优先的应用：** 一般吞吐量优先的应用都有一个很大的年轻代和一个较小的年老代。原因是，这样可以尽可能回收掉大部分短期对象，减少中期的对象，而年老代尽存放长期存活对象。\n\n## 3.较小堆引起的碎片问题\n\n**因为年老代的并发收集器使用标记、清除算法**，所以不会对堆进行压缩。当收集器回收时，他会把相邻的空间进行合并，这样可以分配给较大的对象。但是，当堆空间较小时，运行一段时间以后，就会出现“碎片”，如果并发收集器找不到足够的空间，那么并发收集器将会停止，然后使用传统的标记、清除方式进行回收。如果出现“碎片”，可能需要进行如下配置：\n\n1. -XX:+UseCMSCompactAtFullCollection：使用并发收集器时，开启对年老代的压缩。\n\n2. -XX:CMSFullGCsBeforeCompaction=0：上面配置开启的情况下，这里设置多少次Full GC后，对年老代进行压缩\n\n","source":"_posts/jvm优化.md","raw":"---\ntitle: jvm优化\ndate: 2017-01-03 14:19:45\ntags: \n\t- Jvm优化\n\t- Java优化\n\t\n---\n\n# 常见配置汇总\n## 1.堆设置\n\n\n-Xmx:最大堆内存,如：-Xmx512m\n\n-Xms:初始时堆内存,如：-Xms256m\n\n-XX:MaxNewSize:最大年轻区内存\n\n-XX:NewSize:初始时年轻区内存.通常为 Xmx 的 1/3 或 1/4。新生代 = Eden + 2 个 Survivor 空间。实际可用空间为 = Eden + 1 个 Survivor，即 90%\n\n-XX:MaxPermSize:最大持久带内存\n\n-XX:PermSize:初始时持久带内存\n\n-XX:+PrintGCDetails。打印 GC 信息\n\n -XX:NewRatio 新生代与老年代的比例，如 –XX:NewRatio=2，则新生代占整个堆空间的1/3，老年代占2/3\n\n -XX:SurvivorRatio 新生代中 Eden 与 Survivor 的比值。默认值为 8。即 Eden 占新生代空间的 8/10，另外两个 Survivor 各占 1/10\n\n\n\n\n\n-Xms:初始堆大小，此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。例如：-Xms3550m， 或者-Xms4g\n\n-Xmx:最大堆大小,设置JVM最大可用内存.\n\n-XX:NewSize=n:设置年轻代大小\n\n-XX:NewRatio=n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4\n\n-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5\n\n-XX:MaxPermSize=n:设置持久代大小\n\n## 2.收集器设置\n\n-XX:+UseSerialGC:设置串行收集器\n\n-XX:+UseParallelGC:设置并行收集器\n\n-XX:+UseParalledlOldGC:设置并行年老代收集器\n\n-XX:+UseConcMarkSweepGC:设置并发收集器\n\n## 3.垃圾回收统计信息\n\n-XX:+PrintGC\n\n-XX:+PrintGCDetails\n\n-XX:+PrintGCTimeStamps\n\n-Xloggc:filename\n\n## 4.并行收集器设置\n\n-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。\n\n-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间\n\n-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)\n\n## 5.并发收集器设置\n\n-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。\n\n-XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。\n\n# 调优总结\n## 1.年轻代大小选择\n\n**响应时间优先的应用：** 尽可能设大，直到接近系统的最低响应时间限制（根据实际情况选择）。在此种情况下，年轻代收集发生的频率也是最小的。同时，减少到达年老代的对象。\n\n**吞吐量优先的应用：** 尽可能的设置大，可能到达Gbit的程度。因为对响应时间没有要求，垃圾收集可以并行进行，一般适合8CPU以上的应用。\n\n## 2.年老代大小选择\n\n**响应时间优先的应用：** 年老代使用并发收集器，所以其大小需要小心设置，一般要考虑并发会话率和会话持续时间等一些参数。如果堆设置小了，可以会造成内存碎片、高回收频率以及应用暂停而使用传统的标记清除方式；如果堆大了，则需要较长的收集时间。最优化的方案，一般需要参考以下数据获得：\n\n1. 并发垃圾收集信息\n\n2. 持久代并发收集次数\n\n3. 传统GC信息\n\n4. 花在年轻代和年老代回收上的时间比例\n\n减少年轻代和年老代花费的时间，一般会提高应用的效率\n\n**吞吐量优先的应用：** 一般吞吐量优先的应用都有一个很大的年轻代和一个较小的年老代。原因是，这样可以尽可能回收掉大部分短期对象，减少中期的对象，而年老代尽存放长期存活对象。\n\n## 3.较小堆引起的碎片问题\n\n**因为年老代的并发收集器使用标记、清除算法**，所以不会对堆进行压缩。当收集器回收时，他会把相邻的空间进行合并，这样可以分配给较大的对象。但是，当堆空间较小时，运行一段时间以后，就会出现“碎片”，如果并发收集器找不到足够的空间，那么并发收集器将会停止，然后使用传统的标记、清除方式进行回收。如果出现“碎片”，可能需要进行如下配置：\n\n1. -XX:+UseCMSCompactAtFullCollection：使用并发收集器时，开启对年老代的压缩。\n\n2. -XX:CMSFullGCsBeforeCompaction=0：上面配置开启的情况下，这里设置多少次Full GC后，对年老代进行压缩\n\n","slug":"jvm优化","published":1,"updated":"2019-03-18T09:11:32.183Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtf8e1ct0007v3b8rjj2qyde","content":"<h1 id=\"常见配置汇总\"><a href=\"#常见配置汇总\" class=\"headerlink\" title=\"常见配置汇总\"></a>常见配置汇总</h1><h2 id=\"1-堆设置\"><a href=\"#1-堆设置\" class=\"headerlink\" title=\"1.堆设置\"></a>1.堆设置</h2><p>-Xmx:最大堆内存,如：-Xmx512m</p>\n<p>-Xms:初始时堆内存,如：-Xms256m</p>\n<p>-XX:MaxNewSize:最大年轻区内存</p>\n<p>-XX:NewSize:初始时年轻区内存.通常为 Xmx 的 1/3 或 1/4。新生代 = Eden + 2 个 Survivor 空间。实际可用空间为 = Eden + 1 个 Survivor，即 90%</p>\n<p>-XX:MaxPermSize:最大持久带内存</p>\n<p>-XX:PermSize:初始时持久带内存</p>\n<p>-XX:+PrintGCDetails。打印 GC 信息</p>\n<p> -XX:NewRatio 新生代与老年代的比例，如 –XX:NewRatio=2，则新生代占整个堆空间的1/3，老年代占2/3</p>\n<p> -XX:SurvivorRatio 新生代中 Eden 与 Survivor 的比值。默认值为 8。即 Eden 占新生代空间的 8/10，另外两个 Survivor 各占 1/10</p>\n<p>-Xms:初始堆大小，此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。例如：-Xms3550m， 或者-Xms4g</p>\n<p>-Xmx:最大堆大小,设置JVM最大可用内存.</p>\n<p>-XX:NewSize=n:设置年轻代大小</p>\n<p>-XX:NewRatio=n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4</p>\n<p>-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5</p>\n<p>-XX:MaxPermSize=n:设置持久代大小</p>\n<h2 id=\"2-收集器设置\"><a href=\"#2-收集器设置\" class=\"headerlink\" title=\"2.收集器设置\"></a>2.收集器设置</h2><p>-XX:+UseSerialGC:设置串行收集器</p>\n<p>-XX:+UseParallelGC:设置并行收集器</p>\n<p>-XX:+UseParalledlOldGC:设置并行年老代收集器</p>\n<p>-XX:+UseConcMarkSweepGC:设置并发收集器</p>\n<h2 id=\"3-垃圾回收统计信息\"><a href=\"#3-垃圾回收统计信息\" class=\"headerlink\" title=\"3.垃圾回收统计信息\"></a>3.垃圾回收统计信息</h2><p>-XX:+PrintGC</p>\n<p>-XX:+PrintGCDetails</p>\n<p>-XX:+PrintGCTimeStamps</p>\n<p>-Xloggc:filename</p>\n<h2 id=\"4-并行收集器设置\"><a href=\"#4-并行收集器设置\" class=\"headerlink\" title=\"4.并行收集器设置\"></a>4.并行收集器设置</h2><p>-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。</p>\n<p>-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间</p>\n<p>-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)</p>\n<h2 id=\"5-并发收集器设置\"><a href=\"#5-并发收集器设置\" class=\"headerlink\" title=\"5.并发收集器设置\"></a>5.并发收集器设置</h2><p>-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。</p>\n<p>-XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。</p>\n<h1 id=\"调优总结\"><a href=\"#调优总结\" class=\"headerlink\" title=\"调优总结\"></a>调优总结</h1><h2 id=\"1-年轻代大小选择\"><a href=\"#1-年轻代大小选择\" class=\"headerlink\" title=\"1.年轻代大小选择\"></a>1.年轻代大小选择</h2><p><strong>响应时间优先的应用：</strong> 尽可能设大，直到接近系统的最低响应时间限制（根据实际情况选择）。在此种情况下，年轻代收集发生的频率也是最小的。同时，减少到达年老代的对象。</p>\n<p><strong>吞吐量优先的应用：</strong> 尽可能的设置大，可能到达Gbit的程度。因为对响应时间没有要求，垃圾收集可以并行进行，一般适合8CPU以上的应用。</p>\n<h2 id=\"2-年老代大小选择\"><a href=\"#2-年老代大小选择\" class=\"headerlink\" title=\"2.年老代大小选择\"></a>2.年老代大小选择</h2><p><strong>响应时间优先的应用：</strong> 年老代使用并发收集器，所以其大小需要小心设置，一般要考虑并发会话率和会话持续时间等一些参数。如果堆设置小了，可以会造成内存碎片、高回收频率以及应用暂停而使用传统的标记清除方式；如果堆大了，则需要较长的收集时间。最优化的方案，一般需要参考以下数据获得：</p>\n<ol>\n<li><p>并发垃圾收集信息</p>\n</li>\n<li><p>持久代并发收集次数</p>\n</li>\n<li><p>传统GC信息</p>\n</li>\n<li><p>花在年轻代和年老代回收上的时间比例</p>\n</li>\n</ol>\n<p>减少年轻代和年老代花费的时间，一般会提高应用的效率</p>\n<p><strong>吞吐量优先的应用：</strong> 一般吞吐量优先的应用都有一个很大的年轻代和一个较小的年老代。原因是，这样可以尽可能回收掉大部分短期对象，减少中期的对象，而年老代尽存放长期存活对象。</p>\n<h2 id=\"3-较小堆引起的碎片问题\"><a href=\"#3-较小堆引起的碎片问题\" class=\"headerlink\" title=\"3.较小堆引起的碎片问题\"></a>3.较小堆引起的碎片问题</h2><p><strong>因为年老代的并发收集器使用标记、清除算法</strong>，所以不会对堆进行压缩。当收集器回收时，他会把相邻的空间进行合并，这样可以分配给较大的对象。但是，当堆空间较小时，运行一段时间以后，就会出现“碎片”，如果并发收集器找不到足够的空间，那么并发收集器将会停止，然后使用传统的标记、清除方式进行回收。如果出现“碎片”，可能需要进行如下配置：</p>\n<ol>\n<li><p>-XX:+UseCMSCompactAtFullCollection：使用并发收集器时，开启对年老代的压缩。</p>\n</li>\n<li><p>-XX:CMSFullGCsBeforeCompaction=0：上面配置开启的情况下，这里设置多少次Full GC后，对年老代进行压缩</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"常见配置汇总\"><a href=\"#常见配置汇总\" class=\"headerlink\" title=\"常见配置汇总\"></a>常见配置汇总</h1><h2 id=\"1-堆设置\"><a href=\"#1-堆设置\" class=\"headerlink\" title=\"1.堆设置\"></a>1.堆设置</h2><p>-Xmx:最大堆内存,如：-Xmx512m</p>\n<p>-Xms:初始时堆内存,如：-Xms256m</p>\n<p>-XX:MaxNewSize:最大年轻区内存</p>\n<p>-XX:NewSize:初始时年轻区内存.通常为 Xmx 的 1/3 或 1/4。新生代 = Eden + 2 个 Survivor 空间。实际可用空间为 = Eden + 1 个 Survivor，即 90%</p>\n<p>-XX:MaxPermSize:最大持久带内存</p>\n<p>-XX:PermSize:初始时持久带内存</p>\n<p>-XX:+PrintGCDetails。打印 GC 信息</p>\n<p> -XX:NewRatio 新生代与老年代的比例，如 –XX:NewRatio=2，则新生代占整个堆空间的1/3，老年代占2/3</p>\n<p> -XX:SurvivorRatio 新生代中 Eden 与 Survivor 的比值。默认值为 8。即 Eden 占新生代空间的 8/10，另外两个 Survivor 各占 1/10</p>\n<p>-Xms:初始堆大小，此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。例如：-Xms3550m， 或者-Xms4g</p>\n<p>-Xmx:最大堆大小,设置JVM最大可用内存.</p>\n<p>-XX:NewSize=n:设置年轻代大小</p>\n<p>-XX:NewRatio=n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4</p>\n<p>-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5</p>\n<p>-XX:MaxPermSize=n:设置持久代大小</p>\n<h2 id=\"2-收集器设置\"><a href=\"#2-收集器设置\" class=\"headerlink\" title=\"2.收集器设置\"></a>2.收集器设置</h2><p>-XX:+UseSerialGC:设置串行收集器</p>\n<p>-XX:+UseParallelGC:设置并行收集器</p>\n<p>-XX:+UseParalledlOldGC:设置并行年老代收集器</p>\n<p>-XX:+UseConcMarkSweepGC:设置并发收集器</p>\n<h2 id=\"3-垃圾回收统计信息\"><a href=\"#3-垃圾回收统计信息\" class=\"headerlink\" title=\"3.垃圾回收统计信息\"></a>3.垃圾回收统计信息</h2><p>-XX:+PrintGC</p>\n<p>-XX:+PrintGCDetails</p>\n<p>-XX:+PrintGCTimeStamps</p>\n<p>-Xloggc:filename</p>\n<h2 id=\"4-并行收集器设置\"><a href=\"#4-并行收集器设置\" class=\"headerlink\" title=\"4.并行收集器设置\"></a>4.并行收集器设置</h2><p>-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。</p>\n<p>-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间</p>\n<p>-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)</p>\n<h2 id=\"5-并发收集器设置\"><a href=\"#5-并发收集器设置\" class=\"headerlink\" title=\"5.并发收集器设置\"></a>5.并发收集器设置</h2><p>-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。</p>\n<p>-XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。</p>\n<h1 id=\"调优总结\"><a href=\"#调优总结\" class=\"headerlink\" title=\"调优总结\"></a>调优总结</h1><h2 id=\"1-年轻代大小选择\"><a href=\"#1-年轻代大小选择\" class=\"headerlink\" title=\"1.年轻代大小选择\"></a>1.年轻代大小选择</h2><p><strong>响应时间优先的应用：</strong> 尽可能设大，直到接近系统的最低响应时间限制（根据实际情况选择）。在此种情况下，年轻代收集发生的频率也是最小的。同时，减少到达年老代的对象。</p>\n<p><strong>吞吐量优先的应用：</strong> 尽可能的设置大，可能到达Gbit的程度。因为对响应时间没有要求，垃圾收集可以并行进行，一般适合8CPU以上的应用。</p>\n<h2 id=\"2-年老代大小选择\"><a href=\"#2-年老代大小选择\" class=\"headerlink\" title=\"2.年老代大小选择\"></a>2.年老代大小选择</h2><p><strong>响应时间优先的应用：</strong> 年老代使用并发收集器，所以其大小需要小心设置，一般要考虑并发会话率和会话持续时间等一些参数。如果堆设置小了，可以会造成内存碎片、高回收频率以及应用暂停而使用传统的标记清除方式；如果堆大了，则需要较长的收集时间。最优化的方案，一般需要参考以下数据获得：</p>\n<ol>\n<li><p>并发垃圾收集信息</p>\n</li>\n<li><p>持久代并发收集次数</p>\n</li>\n<li><p>传统GC信息</p>\n</li>\n<li><p>花在年轻代和年老代回收上的时间比例</p>\n</li>\n</ol>\n<p>减少年轻代和年老代花费的时间，一般会提高应用的效率</p>\n<p><strong>吞吐量优先的应用：</strong> 一般吞吐量优先的应用都有一个很大的年轻代和一个较小的年老代。原因是，这样可以尽可能回收掉大部分短期对象，减少中期的对象，而年老代尽存放长期存活对象。</p>\n<h2 id=\"3-较小堆引起的碎片问题\"><a href=\"#3-较小堆引起的碎片问题\" class=\"headerlink\" title=\"3.较小堆引起的碎片问题\"></a>3.较小堆引起的碎片问题</h2><p><strong>因为年老代的并发收集器使用标记、清除算法</strong>，所以不会对堆进行压缩。当收集器回收时，他会把相邻的空间进行合并，这样可以分配给较大的对象。但是，当堆空间较小时，运行一段时间以后，就会出现“碎片”，如果并发收集器找不到足够的空间，那么并发收集器将会停止，然后使用传统的标记、清除方式进行回收。如果出现“碎片”，可能需要进行如下配置：</p>\n<ol>\n<li><p>-XX:+UseCMSCompactAtFullCollection：使用并发收集器时，开启对年老代的压缩。</p>\n</li>\n<li><p>-XX:CMSFullGCsBeforeCompaction=0：上面配置开启的情况下，这里设置多少次Full GC后，对年老代进行压缩</p>\n</li>\n</ol>\n"},{"title":"JVM原理","date":"2018-06-19T08:26:57.000Z","_content":"## 内存\n我们知道，计算机CPU和内存的交互是最频繁的，内存是我们的高速缓存区，用户磁盘和CPU的交互，而CPU运转速度越来越快，磁盘远远跟不上CPU的读写速度，才设计了内存，用户缓冲用户IO等待导致CPU的等待成本，但是随着CPU的发展，内存的读写速度也远远跟不上CPU的读写速度，因此，为了解决这一纠纷，CPU厂商在每颗CPU上加入了高速缓存，用来缓解这种症状，因此，现在CPU同内存交互就变成了下面的样子。\n\n\n<img src=\"../img/cpu.jpg\"> \n\n\n同样，根据摩尔定律，我们知道单核CPU的主频不可能无限制的增长，要想很多的提升新能，需要多个处理器协同工作， Intel总裁的贝瑞特单膝下跪事件标志着多核时代的到来。\n\n基于高速缓存的存储交互很好的解决了处理器与内存之间的矛盾，也引入了新的问题：缓存一致性问题。在多处理器系统中，每个处理器有自己的高速缓存，而他们又共享同一块内存（下文成主存，main memory 主要内存），当多个处理器运算都涉及到同一块内存区域的时候，就有可能发生缓存不一致的现象。为了解决这一问题，需要各个处理器运行时都遵循一些协议，在运行时需要将这些协议保证数据的一致性。这类协议包括MSI、MESI、MOSI、Synapse、Firely、DragonProtocol等。如下图所示\n\n<img src=\"../img/memory.jpg\">\n\nJava虚拟机内存模型中定义的访问操作与物理计算机处理的基本一致！\n<img src=\"../img/java-memory.jpg\">\n\nJava中通过多线程机制使得多个任务同时执行处理，所有的线程共享JVM内存区域main memory，而每个线程又单独的有自己的工作内存，当线程与内存区域进行交互时，数据从主存拷贝到工作内存，进而交由线程处理（操作码+操作数）。更多信息我们会在后面的《深入JVM—JVM类执行机制中详细解说》。\n在之前，我们也已经提到，JVM的逻辑内存模型如下：\n<img src=\"../img/java-memory2.jpg\">\n\n我们现在来逐个的看下每个到底是做什么的！\n\n1、程序计数器\n\n程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。由于Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。如果线程正在执行的是一个Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie 方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在Java 虚拟机规范中没有规定任何OutOfMemoryError 情况的区域。\n\n2、Java 虚拟机栈\n\n与程序计数器一样，Java 虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame ①）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。经常有人把Java 内存区分为堆内存（Heap）和栈内存（Stack），这种分法比较粗糙，Java 内存区域的划分实际上远比这复杂。这种划分方式的流行只能说明大多数程序员最关注的、与对象内存分配关系最密切的内存区域是这两块。其中所指的“堆”在后面会专门讲述，而所指的“栈”就是现在讲的虚拟机栈，或者说是虚拟机栈中的局部变量表部分。局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress 类型（指向了一条字节码指令的地址）。其中64 位长度的long 和double 类型的数据会占用2 个局部变量空间（Slot），其余的数据类型只占用1 个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。在Java 虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError 异常；如果虚拟机栈可以动态扩展（当前大部分的Java 虚拟机都可动态扩展，只不过Java 虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError 异常。\n\n3、本地方法栈\n\n本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native 方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot 虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError 和OutOfMemoryError异常。\n\n4、Java 堆\n\n对于大多数应用来说，Java 堆（Java Heap）是Java 虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java 虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配①，但是随着JIT 编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换②优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。Java 堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC 堆”（GarbageCollected Heap，幸好国内没翻译成“垃圾堆”）。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java 堆中还可以细分为：新生代和老年代；再细致一点的有Eden 空间、From Survivor 空间、To Survivor 空间等。如果从内存分配的角度看，线程共享的Java 堆中可能划分出多个线程私有的分配缓冲区（Thread LocalAllocation Buffer，TLAB）。不过，无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。在本章中，我们仅仅针对内存区域的作用进行讨论，Java 堆中的上述各个区域的分配和回收等细节将会是下一章的主题。根据Java 虚拟机规范的规定，Java 堆可以处于物理上不连续的内存空间中，只逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms 控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError 异常。\n\n4、方法区\n\n方法区（Method Area）与Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java 堆区分开来。对于习惯在HotSpot 虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot 虚拟机的设计团队选择把GC 分代收集扩展至方法区，或者说使用永久代来实现方法区而已。对于其他虚拟机（如BEA JRockit、IBM J9 等）来说是不存在永久代的概念的。即使是HotSpot 虚拟机本身，根据官方发布的路线图信息，现在也有放弃永久代并“搬家”至Native Memory 来实现方法区的规划了。Java 虚拟机规范对这个区域的限制非常宽松，除了和Java 堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。在Sun 公司的BUG 列表中，曾出现过的若干个严重的BUG 就是由于低版本的HotSpot 虚拟机对此区域未完全回收而导致内存泄漏。根据Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError 异常。\n\n5、运行时常量池\n\n运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（Constant PoolTable），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。Java 虚拟机对Class 文件的每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。但对于运行时常量池，Java 虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除了保存Class 文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中①。运行时常量池相对于Class 文件常量池的另外一个重要特征是具备动态性，Java 语言并不要求常量一定只能在编译期产生，也就是并非预置入Class 文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String 类的intern() 方法。既然运行时常量池是方法区的一部分，自然会受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError 异常\n\n6、直接内存\n\n直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError 异常出现，所以我们放到这里一起讲解。在JDK 1.4 中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O 方式，它可以使用Native 函数库直接分配堆外内存，然后通过一个存储在Java 堆里面的DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java 堆和Native 堆中来回复制数据。显然，本机直接内存的分配不会受到Java 堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括RAM 及SWAP 区或者分页文件）的大小及处理器寻址空间的限制。服务器管理员配置虚拟机参数时，一般会根据实际内存设置-Xmx等参数信息，但经常会忽略掉直接内存，使得各个内存区域的总和大于物理内存限制（包括物理上的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。\n\n逻辑内存模型我们已经看到了，那当我们建立一个对象的时候是怎么进行访问的呢？在Java 语言中，对象访问是如何进行的？对象访问在Java 语言中无处不在，是最普通的程序行为，但即使是最简单的访问，也会却涉及Java 栈、Java 堆、方法区这三个最重要内存区\n域之间的关联关系，如下面的这句代码：\n\n```\nObject obj = new Object();\n```\n假设这句代码出现在方法体中，那“Object obj”这部分的语义将会反映到Java 栈的本地变量表中，作为一个reference 类型数据出现。而“new Object()”这部分的语义将会反映到Java 堆中，形成一块存储了Object 类型所有实例数据值（Instance Data，对象中各个实例字段的数据）的结构化内存，根据具体类型以及虚拟机实现的对象内存布局（Object Memory Layout）的不同，这块内存的长度是不固定的。另外，在Java 堆中还必须包含能查找到此对象类型数据（如对象类型、父类、实现的接口、方法等）的地址信息，这些类型数据则存储在方法区中。由于reference 类型在Java 虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到Java 堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：使用句柄和直接指针。如果使用句柄访问方式，Java 堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息，如下图所示。\n<img src=\"../img/java-stack.jpg\">\n\n如果使用直接指针访问方式，Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference 中直接存储的就是对象地址，如下图所示\n\n<img src=\"../img/java-stack2.jpg\">\n\n这两种对象的访问方式各有优势，使用句柄访问方式的最大好处就是reference 中存\n储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference 本身不需要被修改。使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java 中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。就本书讨论的主要虚拟机Sun HotSpot 而言，它是使用第二种方式进行对象访问的，但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见。下面我们来看几个示例\n\n1、Java 堆溢出\n\n下面的程中我们限制Java 堆的大小为20MB，不可扩展（将堆的最小值-Xms 参数与最大值-Xmx 参数设置为一样即可避免堆自动扩展），通过参数-XX:+HeapDumpOnOutOfMemoryError 可以让虚拟机在出现内存溢出异常时Dump 出当前的内存堆转储快照以便事后进行分析。\n参数设置如下\n<img src=\"../img/eclipse-conf.jpg\">\n\n```\npackage com.yhj.jvm.memory.heap;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * @Described：堆溢出测试\n * @VM args:-verbose:gc -Xms20M -Xmx20M -XX:+PrintGCDetails\n * @author YHJ create at 2011-11-12 下午07:52:22\n * @FileNmae com.yhj.jvm.memory.heap.HeapOutOfMemory.java\n */\npublic class HeapOutOfMemory {\n    /**\n     * @param args\n     * @Author YHJ create at 2011-11-12 下午07:52:18\n     */\n    public static void main(String[] args) {\n       List<TestCase> cases = new ArrayList<TestCase>();\n       while(true){\n           cases.add(new TestCase());\n       }\n    }\n}\n\n/**\n * @Described：测试用例\n * @author YHJ create at 2011-11-12 下午07:55:50\n * @FileNmae com.yhj.jvm.memory.heap.HeapOutOfMemory.java\n */\nclass TestCase{\n}\n\n```\nJava 堆内存的OutOfMemoryError异常是实际应用中最常见的内存溢出异常情况。出现Java 堆内\n存溢出时，异常堆栈信息“java.lang.OutOfMemoryError”会跟着进一步提示“Java heap\n\nspace”。\n\n要解决这个区域的异常，一般的手段是首先通过内存映像分析工具（如Eclipse\n\nMemory Analyzer）对dump 出来的堆转储快照进行分析，重点是确认内存中的对象是\n\n否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢\n\n出（Memory Overflow）。图2-5 显示了使用Eclipse Memory Analyzer 打开的堆转储快\n\n照文件。\n\n如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots 的引用链。于是就\n\n能找到泄漏对象是通过怎样的路径与GC Roots 相关联并导致垃圾收集器无法自动回收\n\n它们的。掌握了泄漏对象的类型信息，以及GC Roots 引用链的信息，就可以比较准确\n\n地定位出泄漏代码的位置。\n\n如果不存在泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查\n\n虚拟机的堆参数（-Xmx 与-Xms），与机器物理内存对比看是否还可以调大，从代码上\n\n检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期\n\n的内存消耗。\n\n以上是处理Java 堆内存问题的简略思路，处理这些问题所需要的知识、工具与经验\n\n在后面的几次分享中我会做一些额外的分析。\n\n2、java栈溢出\n\n```\npackage com.yhj.jvm.memory.stack;\n\n/**\n * @Described：栈层级不足探究\n * @VM args:-Xss128k\n * @author YHJ create at 2011-11-12 下午08:19:28\n * @FileNmae com.yhj.jvm.memory.stack.StackOverFlow.java\n */\npublic class StackOverFlow {\n    private int i ;\n    public void plus() {\n       i++;\n       plus();\n    }\n    \n    /**\n     * @param args\n     * @Author YHJ create at 2011-11-12 下午08:19:21\n     */\n    public static void main(String[] args) {\n       StackOverFlow stackOverFlow = new StackOverFlow();\n       try {\n           stackOverFlow.plus();\n       } catch (Exception e) {\n           System.out.println(\"Exception:stack length:\"+stackOverFlow.i);\n           e.printStackTrace();\n       } catch (Error e) {\n           System.out.println(\"Error:stack length:\"+stackOverFlow.i);\n           e.printStackTrace();\n       }\n    }\n}\n```\n3、常量池溢出（常量池都有哪些信息，我们在后续的JVM类文件结构中详细描述）\n\n```\npackage com.yhj.jvm.memory.constant;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * @Described：常量池内存溢出探究\n * @VM args : -XX:PermSize=10M -XX:MaxPermSize=10M\n * @author YHJ create at 2011-10-30 下午04:28:30\n * @FileNmae com.yhj.jvm.memory.constant.ConstantOutOfMemory.java\n */\npublic class ConstantOutOfMemory {\n    /**\n     * @param args\n     * @throws Exception\n     * @Author YHJ create at 2011-10-30 下午04:28:25\n     */\n    public static void main(String[] args) throws Exception {\n       try {\n           List<String> strings = new ArrayList<String>();\n           int i = 0;\n           while(true){\n              strings.add(String.valueOf(i++).intern());\n           }\n       } catch (Exception e) {\n           e.printStackTrace();\n           throw e;\n       }\n    }\n}\n```\n4、方法去溢出\n\n```\npackage com.yhj.jvm.memory.methodArea;\nimport java.lang.reflect.Method;\nimport net.sf.cglib.proxy.Enhancer;\nimport net.sf.cglib.proxy.MethodInterceptor;\nimport net.sf.cglib.proxy.MethodProxy;\n\n/**\n * @Described：方法区溢出测试\n * 使用技术 CBlib\n * @VM args : -XX:PermSize=10M -XX:MaxPermSize=10M\n * @author YHJ create at 2011-11-12 下午08:47:55\n * @FileNmae com.yhj.jvm.memory.methodArea.MethodAreaOutOfMemory.java\n */\n\npublic class MethodAreaOutOfMemory {\n\n    /**\n     * @param args\n     * @Author YHJ create at 2011-11-12 下午08:47:51\n     */\n    public static void main(String[] args) {\n       while(true){\n           Enhancer enhancer = new Enhancer();\n           enhancer.setSuperclass(TestCase.class);\n           enhancer.setUseCache(false);\n           enhancer.setCallback(new MethodInterceptor() {\n              @Override\n              public Object intercept(Object arg0, Method arg1, Object[] arg2,\n                  MethodProxy arg3) throws Throwable {\n                  return arg3.invokeSuper(arg0, arg2);\n              }\n           });\n           enhancer.create();\n       }\n    }\n}\n\n/**\n * @Described：测试用例\n * @author YHJ create at 2011-11-12 下午08:53:09\n * @FileNmae com.yhj.jvm.memory.methodArea.MethodAreaOutOfMemory.java\n */\nclass TestCase{\n}\n```\n5、直接内存溢出\n\n```\npackage com.yhj.jvm.memory.directoryMemory;\nimport java.lang.reflect.Field;\nimport sun.misc.Unsafe;\n\n/**\n * @Described：直接内存溢出测试\n * @VM args: -Xmx20M -XX:MaxDirectMemorySize=10M\n * @author YHJ create at 2011-11-12 下午09:06:10\n * @FileNmae \n */\npublic class DirectoryMemoryOutOfmemory {\n    private static final int ONE_MB = 1024*1024;\n    private static int count = 1;\n    \n    /**\n     * @param args\n     * @Author YHJ create at 2011-11-12 下午09:05:54\n     */\n    public static void main(String[] args) {\n       try {\n           Field field = Unsafe.class.getDeclaredField(\"theUnsafe\");\n           field.setAccessible(true);\n           Unsafe unsafe = (Unsafe) field.get(null);\n           while (true) {\n              unsafe.allocateMemory(ONE_MB);\n              count++;\n           }\n       } catch (Exception e) {\n           System.out.println(\"Exception:instance created \"+count);\n           e.printStackTrace();\n       } catch (Error e) {\n           System.out.println(\"Error:instance created \"+count);\n           e.printStackTrace();\n       }\n    }\n}\n\n```\n\n\n ","source":"_posts/JVM原理.md","raw":"---\ntitle: JVM原理\ndate: 2018-06-19 16:26:57\ntags:\n  - Jvm\n  - 原理\n---\n## 内存\n我们知道，计算机CPU和内存的交互是最频繁的，内存是我们的高速缓存区，用户磁盘和CPU的交互，而CPU运转速度越来越快，磁盘远远跟不上CPU的读写速度，才设计了内存，用户缓冲用户IO等待导致CPU的等待成本，但是随着CPU的发展，内存的读写速度也远远跟不上CPU的读写速度，因此，为了解决这一纠纷，CPU厂商在每颗CPU上加入了高速缓存，用来缓解这种症状，因此，现在CPU同内存交互就变成了下面的样子。\n\n\n<img src=\"../img/cpu.jpg\"> \n\n\n同样，根据摩尔定律，我们知道单核CPU的主频不可能无限制的增长，要想很多的提升新能，需要多个处理器协同工作， Intel总裁的贝瑞特单膝下跪事件标志着多核时代的到来。\n\n基于高速缓存的存储交互很好的解决了处理器与内存之间的矛盾，也引入了新的问题：缓存一致性问题。在多处理器系统中，每个处理器有自己的高速缓存，而他们又共享同一块内存（下文成主存，main memory 主要内存），当多个处理器运算都涉及到同一块内存区域的时候，就有可能发生缓存不一致的现象。为了解决这一问题，需要各个处理器运行时都遵循一些协议，在运行时需要将这些协议保证数据的一致性。这类协议包括MSI、MESI、MOSI、Synapse、Firely、DragonProtocol等。如下图所示\n\n<img src=\"../img/memory.jpg\">\n\nJava虚拟机内存模型中定义的访问操作与物理计算机处理的基本一致！\n<img src=\"../img/java-memory.jpg\">\n\nJava中通过多线程机制使得多个任务同时执行处理，所有的线程共享JVM内存区域main memory，而每个线程又单独的有自己的工作内存，当线程与内存区域进行交互时，数据从主存拷贝到工作内存，进而交由线程处理（操作码+操作数）。更多信息我们会在后面的《深入JVM—JVM类执行机制中详细解说》。\n在之前，我们也已经提到，JVM的逻辑内存模型如下：\n<img src=\"../img/java-memory2.jpg\">\n\n我们现在来逐个的看下每个到底是做什么的！\n\n1、程序计数器\n\n程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。由于Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。如果线程正在执行的是一个Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie 方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在Java 虚拟机规范中没有规定任何OutOfMemoryError 情况的区域。\n\n2、Java 虚拟机栈\n\n与程序计数器一样，Java 虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame ①）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。经常有人把Java 内存区分为堆内存（Heap）和栈内存（Stack），这种分法比较粗糙，Java 内存区域的划分实际上远比这复杂。这种划分方式的流行只能说明大多数程序员最关注的、与对象内存分配关系最密切的内存区域是这两块。其中所指的“堆”在后面会专门讲述，而所指的“栈”就是现在讲的虚拟机栈，或者说是虚拟机栈中的局部变量表部分。局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress 类型（指向了一条字节码指令的地址）。其中64 位长度的long 和double 类型的数据会占用2 个局部变量空间（Slot），其余的数据类型只占用1 个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。在Java 虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError 异常；如果虚拟机栈可以动态扩展（当前大部分的Java 虚拟机都可动态扩展，只不过Java 虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError 异常。\n\n3、本地方法栈\n\n本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native 方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot 虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError 和OutOfMemoryError异常。\n\n4、Java 堆\n\n对于大多数应用来说，Java 堆（Java Heap）是Java 虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java 虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配①，但是随着JIT 编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换②优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。Java 堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC 堆”（GarbageCollected Heap，幸好国内没翻译成“垃圾堆”）。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java 堆中还可以细分为：新生代和老年代；再细致一点的有Eden 空间、From Survivor 空间、To Survivor 空间等。如果从内存分配的角度看，线程共享的Java 堆中可能划分出多个线程私有的分配缓冲区（Thread LocalAllocation Buffer，TLAB）。不过，无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。在本章中，我们仅仅针对内存区域的作用进行讨论，Java 堆中的上述各个区域的分配和回收等细节将会是下一章的主题。根据Java 虚拟机规范的规定，Java 堆可以处于物理上不连续的内存空间中，只逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms 控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError 异常。\n\n4、方法区\n\n方法区（Method Area）与Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java 堆区分开来。对于习惯在HotSpot 虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot 虚拟机的设计团队选择把GC 分代收集扩展至方法区，或者说使用永久代来实现方法区而已。对于其他虚拟机（如BEA JRockit、IBM J9 等）来说是不存在永久代的概念的。即使是HotSpot 虚拟机本身，根据官方发布的路线图信息，现在也有放弃永久代并“搬家”至Native Memory 来实现方法区的规划了。Java 虚拟机规范对这个区域的限制非常宽松，除了和Java 堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。在Sun 公司的BUG 列表中，曾出现过的若干个严重的BUG 就是由于低版本的HotSpot 虚拟机对此区域未完全回收而导致内存泄漏。根据Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError 异常。\n\n5、运行时常量池\n\n运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（Constant PoolTable），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。Java 虚拟机对Class 文件的每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。但对于运行时常量池，Java 虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除了保存Class 文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中①。运行时常量池相对于Class 文件常量池的另外一个重要特征是具备动态性，Java 语言并不要求常量一定只能在编译期产生，也就是并非预置入Class 文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String 类的intern() 方法。既然运行时常量池是方法区的一部分，自然会受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError 异常\n\n6、直接内存\n\n直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError 异常出现，所以我们放到这里一起讲解。在JDK 1.4 中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O 方式，它可以使用Native 函数库直接分配堆外内存，然后通过一个存储在Java 堆里面的DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java 堆和Native 堆中来回复制数据。显然，本机直接内存的分配不会受到Java 堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括RAM 及SWAP 区或者分页文件）的大小及处理器寻址空间的限制。服务器管理员配置虚拟机参数时，一般会根据实际内存设置-Xmx等参数信息，但经常会忽略掉直接内存，使得各个内存区域的总和大于物理内存限制（包括物理上的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。\n\n逻辑内存模型我们已经看到了，那当我们建立一个对象的时候是怎么进行访问的呢？在Java 语言中，对象访问是如何进行的？对象访问在Java 语言中无处不在，是最普通的程序行为，但即使是最简单的访问，也会却涉及Java 栈、Java 堆、方法区这三个最重要内存区\n域之间的关联关系，如下面的这句代码：\n\n```\nObject obj = new Object();\n```\n假设这句代码出现在方法体中，那“Object obj”这部分的语义将会反映到Java 栈的本地变量表中，作为一个reference 类型数据出现。而“new Object()”这部分的语义将会反映到Java 堆中，形成一块存储了Object 类型所有实例数据值（Instance Data，对象中各个实例字段的数据）的结构化内存，根据具体类型以及虚拟机实现的对象内存布局（Object Memory Layout）的不同，这块内存的长度是不固定的。另外，在Java 堆中还必须包含能查找到此对象类型数据（如对象类型、父类、实现的接口、方法等）的地址信息，这些类型数据则存储在方法区中。由于reference 类型在Java 虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到Java 堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：使用句柄和直接指针。如果使用句柄访问方式，Java 堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息，如下图所示。\n<img src=\"../img/java-stack.jpg\">\n\n如果使用直接指针访问方式，Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference 中直接存储的就是对象地址，如下图所示\n\n<img src=\"../img/java-stack2.jpg\">\n\n这两种对象的访问方式各有优势，使用句柄访问方式的最大好处就是reference 中存\n储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference 本身不需要被修改。使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java 中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。就本书讨论的主要虚拟机Sun HotSpot 而言，它是使用第二种方式进行对象访问的，但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见。下面我们来看几个示例\n\n1、Java 堆溢出\n\n下面的程中我们限制Java 堆的大小为20MB，不可扩展（将堆的最小值-Xms 参数与最大值-Xmx 参数设置为一样即可避免堆自动扩展），通过参数-XX:+HeapDumpOnOutOfMemoryError 可以让虚拟机在出现内存溢出异常时Dump 出当前的内存堆转储快照以便事后进行分析。\n参数设置如下\n<img src=\"../img/eclipse-conf.jpg\">\n\n```\npackage com.yhj.jvm.memory.heap;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * @Described：堆溢出测试\n * @VM args:-verbose:gc -Xms20M -Xmx20M -XX:+PrintGCDetails\n * @author YHJ create at 2011-11-12 下午07:52:22\n * @FileNmae com.yhj.jvm.memory.heap.HeapOutOfMemory.java\n */\npublic class HeapOutOfMemory {\n    /**\n     * @param args\n     * @Author YHJ create at 2011-11-12 下午07:52:18\n     */\n    public static void main(String[] args) {\n       List<TestCase> cases = new ArrayList<TestCase>();\n       while(true){\n           cases.add(new TestCase());\n       }\n    }\n}\n\n/**\n * @Described：测试用例\n * @author YHJ create at 2011-11-12 下午07:55:50\n * @FileNmae com.yhj.jvm.memory.heap.HeapOutOfMemory.java\n */\nclass TestCase{\n}\n\n```\nJava 堆内存的OutOfMemoryError异常是实际应用中最常见的内存溢出异常情况。出现Java 堆内\n存溢出时，异常堆栈信息“java.lang.OutOfMemoryError”会跟着进一步提示“Java heap\n\nspace”。\n\n要解决这个区域的异常，一般的手段是首先通过内存映像分析工具（如Eclipse\n\nMemory Analyzer）对dump 出来的堆转储快照进行分析，重点是确认内存中的对象是\n\n否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢\n\n出（Memory Overflow）。图2-5 显示了使用Eclipse Memory Analyzer 打开的堆转储快\n\n照文件。\n\n如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots 的引用链。于是就\n\n能找到泄漏对象是通过怎样的路径与GC Roots 相关联并导致垃圾收集器无法自动回收\n\n它们的。掌握了泄漏对象的类型信息，以及GC Roots 引用链的信息，就可以比较准确\n\n地定位出泄漏代码的位置。\n\n如果不存在泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查\n\n虚拟机的堆参数（-Xmx 与-Xms），与机器物理内存对比看是否还可以调大，从代码上\n\n检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期\n\n的内存消耗。\n\n以上是处理Java 堆内存问题的简略思路，处理这些问题所需要的知识、工具与经验\n\n在后面的几次分享中我会做一些额外的分析。\n\n2、java栈溢出\n\n```\npackage com.yhj.jvm.memory.stack;\n\n/**\n * @Described：栈层级不足探究\n * @VM args:-Xss128k\n * @author YHJ create at 2011-11-12 下午08:19:28\n * @FileNmae com.yhj.jvm.memory.stack.StackOverFlow.java\n */\npublic class StackOverFlow {\n    private int i ;\n    public void plus() {\n       i++;\n       plus();\n    }\n    \n    /**\n     * @param args\n     * @Author YHJ create at 2011-11-12 下午08:19:21\n     */\n    public static void main(String[] args) {\n       StackOverFlow stackOverFlow = new StackOverFlow();\n       try {\n           stackOverFlow.plus();\n       } catch (Exception e) {\n           System.out.println(\"Exception:stack length:\"+stackOverFlow.i);\n           e.printStackTrace();\n       } catch (Error e) {\n           System.out.println(\"Error:stack length:\"+stackOverFlow.i);\n           e.printStackTrace();\n       }\n    }\n}\n```\n3、常量池溢出（常量池都有哪些信息，我们在后续的JVM类文件结构中详细描述）\n\n```\npackage com.yhj.jvm.memory.constant;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * @Described：常量池内存溢出探究\n * @VM args : -XX:PermSize=10M -XX:MaxPermSize=10M\n * @author YHJ create at 2011-10-30 下午04:28:30\n * @FileNmae com.yhj.jvm.memory.constant.ConstantOutOfMemory.java\n */\npublic class ConstantOutOfMemory {\n    /**\n     * @param args\n     * @throws Exception\n     * @Author YHJ create at 2011-10-30 下午04:28:25\n     */\n    public static void main(String[] args) throws Exception {\n       try {\n           List<String> strings = new ArrayList<String>();\n           int i = 0;\n           while(true){\n              strings.add(String.valueOf(i++).intern());\n           }\n       } catch (Exception e) {\n           e.printStackTrace();\n           throw e;\n       }\n    }\n}\n```\n4、方法去溢出\n\n```\npackage com.yhj.jvm.memory.methodArea;\nimport java.lang.reflect.Method;\nimport net.sf.cglib.proxy.Enhancer;\nimport net.sf.cglib.proxy.MethodInterceptor;\nimport net.sf.cglib.proxy.MethodProxy;\n\n/**\n * @Described：方法区溢出测试\n * 使用技术 CBlib\n * @VM args : -XX:PermSize=10M -XX:MaxPermSize=10M\n * @author YHJ create at 2011-11-12 下午08:47:55\n * @FileNmae com.yhj.jvm.memory.methodArea.MethodAreaOutOfMemory.java\n */\n\npublic class MethodAreaOutOfMemory {\n\n    /**\n     * @param args\n     * @Author YHJ create at 2011-11-12 下午08:47:51\n     */\n    public static void main(String[] args) {\n       while(true){\n           Enhancer enhancer = new Enhancer();\n           enhancer.setSuperclass(TestCase.class);\n           enhancer.setUseCache(false);\n           enhancer.setCallback(new MethodInterceptor() {\n              @Override\n              public Object intercept(Object arg0, Method arg1, Object[] arg2,\n                  MethodProxy arg3) throws Throwable {\n                  return arg3.invokeSuper(arg0, arg2);\n              }\n           });\n           enhancer.create();\n       }\n    }\n}\n\n/**\n * @Described：测试用例\n * @author YHJ create at 2011-11-12 下午08:53:09\n * @FileNmae com.yhj.jvm.memory.methodArea.MethodAreaOutOfMemory.java\n */\nclass TestCase{\n}\n```\n5、直接内存溢出\n\n```\npackage com.yhj.jvm.memory.directoryMemory;\nimport java.lang.reflect.Field;\nimport sun.misc.Unsafe;\n\n/**\n * @Described：直接内存溢出测试\n * @VM args: -Xmx20M -XX:MaxDirectMemorySize=10M\n * @author YHJ create at 2011-11-12 下午09:06:10\n * @FileNmae \n */\npublic class DirectoryMemoryOutOfmemory {\n    private static final int ONE_MB = 1024*1024;\n    private static int count = 1;\n    \n    /**\n     * @param args\n     * @Author YHJ create at 2011-11-12 下午09:05:54\n     */\n    public static void main(String[] args) {\n       try {\n           Field field = Unsafe.class.getDeclaredField(\"theUnsafe\");\n           field.setAccessible(true);\n           Unsafe unsafe = (Unsafe) field.get(null);\n           while (true) {\n              unsafe.allocateMemory(ONE_MB);\n              count++;\n           }\n       } catch (Exception e) {\n           System.out.println(\"Exception:instance created \"+count);\n           e.printStackTrace();\n       } catch (Error e) {\n           System.out.println(\"Error:instance created \"+count);\n           e.printStackTrace();\n       }\n    }\n}\n\n```\n\n\n ","slug":"JVM原理","published":1,"updated":"2019-03-18T09:11:32.183Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtf8e1cx000hv3b8aik3rmm7","content":"<h2 id=\"内存\"><a href=\"#内存\" class=\"headerlink\" title=\"内存\"></a>内存</h2><p>我们知道，计算机CPU和内存的交互是最频繁的，内存是我们的高速缓存区，用户磁盘和CPU的交互，而CPU运转速度越来越快，磁盘远远跟不上CPU的读写速度，才设计了内存，用户缓冲用户IO等待导致CPU的等待成本，但是随着CPU的发展，内存的读写速度也远远跟不上CPU的读写速度，因此，为了解决这一纠纷，CPU厂商在每颗CPU上加入了高速缓存，用来缓解这种症状，因此，现在CPU同内存交互就变成了下面的样子。</p>\n<p><img src=\"../img/cpu.jpg\"> </p>\n<p>同样，根据摩尔定律，我们知道单核CPU的主频不可能无限制的增长，要想很多的提升新能，需要多个处理器协同工作， Intel总裁的贝瑞特单膝下跪事件标志着多核时代的到来。</p>\n<p>基于高速缓存的存储交互很好的解决了处理器与内存之间的矛盾，也引入了新的问题：缓存一致性问题。在多处理器系统中，每个处理器有自己的高速缓存，而他们又共享同一块内存（下文成主存，main memory 主要内存），当多个处理器运算都涉及到同一块内存区域的时候，就有可能发生缓存不一致的现象。为了解决这一问题，需要各个处理器运行时都遵循一些协议，在运行时需要将这些协议保证数据的一致性。这类协议包括MSI、MESI、MOSI、Synapse、Firely、DragonProtocol等。如下图所示</p>\n<p><img src=\"../img/memory.jpg\"></p>\n<p>Java虚拟机内存模型中定义的访问操作与物理计算机处理的基本一致！<br><img src=\"../img/java-memory.jpg\"></p>\n<p>Java中通过多线程机制使得多个任务同时执行处理，所有的线程共享JVM内存区域main memory，而每个线程又单独的有自己的工作内存，当线程与内存区域进行交互时，数据从主存拷贝到工作内存，进而交由线程处理（操作码+操作数）。更多信息我们会在后面的《深入JVM—JVM类执行机制中详细解说》。<br>在之前，我们也已经提到，JVM的逻辑内存模型如下：<br><img src=\"../img/java-memory2.jpg\"></p>\n<p>我们现在来逐个的看下每个到底是做什么的！</p>\n<p>1、程序计数器</p>\n<p>程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。由于Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。如果线程正在执行的是一个Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie 方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在Java 虚拟机规范中没有规定任何OutOfMemoryError 情况的区域。</p>\n<p>2、Java 虚拟机栈</p>\n<p>与程序计数器一样，Java 虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame ①）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。经常有人把Java 内存区分为堆内存（Heap）和栈内存（Stack），这种分法比较粗糙，Java 内存区域的划分实际上远比这复杂。这种划分方式的流行只能说明大多数程序员最关注的、与对象内存分配关系最密切的内存区域是这两块。其中所指的“堆”在后面会专门讲述，而所指的“栈”就是现在讲的虚拟机栈，或者说是虚拟机栈中的局部变量表部分。局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress 类型（指向了一条字节码指令的地址）。其中64 位长度的long 和double 类型的数据会占用2 个局部变量空间（Slot），其余的数据类型只占用1 个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。在Java 虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError 异常；如果虚拟机栈可以动态扩展（当前大部分的Java 虚拟机都可动态扩展，只不过Java 虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError 异常。</p>\n<p>3、本地方法栈</p>\n<p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native 方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot 虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError 和OutOfMemoryError异常。</p>\n<p>4、Java 堆</p>\n<p>对于大多数应用来说，Java 堆（Java Heap）是Java 虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java 虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配①，但是随着JIT 编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换②优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。Java 堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC 堆”（GarbageCollected Heap，幸好国内没翻译成“垃圾堆”）。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java 堆中还可以细分为：新生代和老年代；再细致一点的有Eden 空间、From Survivor 空间、To Survivor 空间等。如果从内存分配的角度看，线程共享的Java 堆中可能划分出多个线程私有的分配缓冲区（Thread LocalAllocation Buffer，TLAB）。不过，无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。在本章中，我们仅仅针对内存区域的作用进行讨论，Java 堆中的上述各个区域的分配和回收等细节将会是下一章的主题。根据Java 虚拟机规范的规定，Java 堆可以处于物理上不连续的内存空间中，只逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms 控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError 异常。</p>\n<p>4、方法区</p>\n<p>方法区（Method Area）与Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java 堆区分开来。对于习惯在HotSpot 虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot 虚拟机的设计团队选择把GC 分代收集扩展至方法区，或者说使用永久代来实现方法区而已。对于其他虚拟机（如BEA JRockit、IBM J9 等）来说是不存在永久代的概念的。即使是HotSpot 虚拟机本身，根据官方发布的路线图信息，现在也有放弃永久代并“搬家”至Native Memory 来实现方法区的规划了。Java 虚拟机规范对这个区域的限制非常宽松，除了和Java 堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。在Sun 公司的BUG 列表中，曾出现过的若干个严重的BUG 就是由于低版本的HotSpot 虚拟机对此区域未完全回收而导致内存泄漏。根据Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError 异常。</p>\n<p>5、运行时常量池</p>\n<p>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（Constant PoolTable），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。Java 虚拟机对Class 文件的每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。但对于运行时常量池，Java 虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除了保存Class 文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中①。运行时常量池相对于Class 文件常量池的另外一个重要特征是具备动态性，Java 语言并不要求常量一定只能在编译期产生，也就是并非预置入Class 文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String 类的intern() 方法。既然运行时常量池是方法区的一部分，自然会受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError 异常</p>\n<p>6、直接内存</p>\n<p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError 异常出现，所以我们放到这里一起讲解。在JDK 1.4 中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O 方式，它可以使用Native 函数库直接分配堆外内存，然后通过一个存储在Java 堆里面的DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java 堆和Native 堆中来回复制数据。显然，本机直接内存的分配不会受到Java 堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括RAM 及SWAP 区或者分页文件）的大小及处理器寻址空间的限制。服务器管理员配置虚拟机参数时，一般会根据实际内存设置-Xmx等参数信息，但经常会忽略掉直接内存，使得各个内存区域的总和大于物理内存限制（包括物理上的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。</p>\n<p>逻辑内存模型我们已经看到了，那当我们建立一个对象的时候是怎么进行访问的呢？在Java 语言中，对象访问是如何进行的？对象访问在Java 语言中无处不在，是最普通的程序行为，但即使是最简单的访问，也会却涉及Java 栈、Java 堆、方法区这三个最重要内存区<br>域之间的关联关系，如下面的这句代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object obj = new Object();</span><br></pre></td></tr></table></figure>\n<p>假设这句代码出现在方法体中，那“Object obj”这部分的语义将会反映到Java 栈的本地变量表中，作为一个reference 类型数据出现。而“new Object()”这部分的语义将会反映到Java 堆中，形成一块存储了Object 类型所有实例数据值（Instance Data，对象中各个实例字段的数据）的结构化内存，根据具体类型以及虚拟机实现的对象内存布局（Object Memory Layout）的不同，这块内存的长度是不固定的。另外，在Java 堆中还必须包含能查找到此对象类型数据（如对象类型、父类、实现的接口、方法等）的地址信息，这些类型数据则存储在方法区中。由于reference 类型在Java 虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到Java 堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：使用句柄和直接指针。如果使用句柄访问方式，Java 堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息，如下图所示。<br><img src=\"../img/java-stack.jpg\"></p>\n<p>如果使用直接指针访问方式，Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference 中直接存储的就是对象地址，如下图所示</p>\n<p><img src=\"../img/java-stack2.jpg\"></p>\n<p>这两种对象的访问方式各有优势，使用句柄访问方式的最大好处就是reference 中存<br>储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference 本身不需要被修改。使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java 中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。就本书讨论的主要虚拟机Sun HotSpot 而言，它是使用第二种方式进行对象访问的，但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见。下面我们来看几个示例</p>\n<p>1、Java 堆溢出</p>\n<p>下面的程中我们限制Java 堆的大小为20MB，不可扩展（将堆的最小值-Xms 参数与最大值-Xmx 参数设置为一样即可避免堆自动扩展），通过参数-XX:+HeapDumpOnOutOfMemoryError 可以让虚拟机在出现内存溢出异常时Dump 出当前的内存堆转储快照以便事后进行分析。<br>参数设置如下<br><img src=\"../img/eclipse-conf.jpg\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.yhj.jvm.memory.heap;</span><br><span class=\"line\">import java.util.ArrayList;</span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @Described：堆溢出测试</span><br><span class=\"line\"> * @VM args:-verbose:gc -Xms20M -Xmx20M -XX:+PrintGCDetails</span><br><span class=\"line\"> * @author YHJ create at 2011-11-12 下午07:52:22</span><br><span class=\"line\"> * @FileNmae com.yhj.jvm.memory.heap.HeapOutOfMemory.java</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class HeapOutOfMemory &#123;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * @param args</span><br><span class=\"line\">     * @Author YHJ create at 2011-11-12 下午07:52:18</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">       List&lt;TestCase&gt; cases = new ArrayList&lt;TestCase&gt;();</span><br><span class=\"line\">       while(true)&#123;</span><br><span class=\"line\">           cases.add(new TestCase());</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @Described：测试用例</span><br><span class=\"line\"> * @author YHJ create at 2011-11-12 下午07:55:50</span><br><span class=\"line\"> * @FileNmae com.yhj.jvm.memory.heap.HeapOutOfMemory.java</span><br><span class=\"line\"> */</span><br><span class=\"line\">class TestCase&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Java 堆内存的OutOfMemoryError异常是实际应用中最常见的内存溢出异常情况。出现Java 堆内<br>存溢出时，异常堆栈信息“java.lang.OutOfMemoryError”会跟着进一步提示“Java heap</p>\n<p>space”。</p>\n<p>要解决这个区域的异常，一般的手段是首先通过内存映像分析工具（如Eclipse</p>\n<p>Memory Analyzer）对dump 出来的堆转储快照进行分析，重点是确认内存中的对象是</p>\n<p>否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢</p>\n<p>出（Memory Overflow）。图2-5 显示了使用Eclipse Memory Analyzer 打开的堆转储快</p>\n<p>照文件。</p>\n<p>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots 的引用链。于是就</p>\n<p>能找到泄漏对象是通过怎样的路径与GC Roots 相关联并导致垃圾收集器无法自动回收</p>\n<p>它们的。掌握了泄漏对象的类型信息，以及GC Roots 引用链的信息，就可以比较准确</p>\n<p>地定位出泄漏代码的位置。</p>\n<p>如果不存在泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查</p>\n<p>虚拟机的堆参数（-Xmx 与-Xms），与机器物理内存对比看是否还可以调大，从代码上</p>\n<p>检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期</p>\n<p>的内存消耗。</p>\n<p>以上是处理Java 堆内存问题的简略思路，处理这些问题所需要的知识、工具与经验</p>\n<p>在后面的几次分享中我会做一些额外的分析。</p>\n<p>2、java栈溢出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.yhj.jvm.memory.stack;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @Described：栈层级不足探究</span><br><span class=\"line\"> * @VM args:-Xss128k</span><br><span class=\"line\"> * @author YHJ create at 2011-11-12 下午08:19:28</span><br><span class=\"line\"> * @FileNmae com.yhj.jvm.memory.stack.StackOverFlow.java</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class StackOverFlow &#123;</span><br><span class=\"line\">    private int i ;</span><br><span class=\"line\">    public void plus() &#123;</span><br><span class=\"line\">       i++;</span><br><span class=\"line\">       plus();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * @param args</span><br><span class=\"line\">     * @Author YHJ create at 2011-11-12 下午08:19:21</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">       StackOverFlow stackOverFlow = new StackOverFlow();</span><br><span class=\"line\">       try &#123;</span><br><span class=\"line\">           stackOverFlow.plus();</span><br><span class=\"line\">       &#125; catch (Exception e) &#123;</span><br><span class=\"line\">           System.out.println(&quot;Exception:stack length:&quot;+stackOverFlow.i);</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125; catch (Error e) &#123;</span><br><span class=\"line\">           System.out.println(&quot;Error:stack length:&quot;+stackOverFlow.i);</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>3、常量池溢出（常量池都有哪些信息，我们在后续的JVM类文件结构中详细描述）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.yhj.jvm.memory.constant;</span><br><span class=\"line\">import java.util.ArrayList;</span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @Described：常量池内存溢出探究</span><br><span class=\"line\"> * @VM args : -XX:PermSize=10M -XX:MaxPermSize=10M</span><br><span class=\"line\"> * @author YHJ create at 2011-10-30 下午04:28:30</span><br><span class=\"line\"> * @FileNmae com.yhj.jvm.memory.constant.ConstantOutOfMemory.java</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class ConstantOutOfMemory &#123;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * @param args</span><br><span class=\"line\">     * @throws Exception</span><br><span class=\"line\">     * @Author YHJ create at 2011-10-30 下午04:28:25</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\">       try &#123;</span><br><span class=\"line\">           List&lt;String&gt; strings = new ArrayList&lt;String&gt;();</span><br><span class=\"line\">           int i = 0;</span><br><span class=\"line\">           while(true)&#123;</span><br><span class=\"line\">              strings.add(String.valueOf(i++).intern());</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125; catch (Exception e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">           throw e;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>4、方法去溢出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.yhj.jvm.memory.methodArea;</span><br><span class=\"line\">import java.lang.reflect.Method;</span><br><span class=\"line\">import net.sf.cglib.proxy.Enhancer;</span><br><span class=\"line\">import net.sf.cglib.proxy.MethodInterceptor;</span><br><span class=\"line\">import net.sf.cglib.proxy.MethodProxy;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @Described：方法区溢出测试</span><br><span class=\"line\"> * 使用技术 CBlib</span><br><span class=\"line\"> * @VM args : -XX:PermSize=10M -XX:MaxPermSize=10M</span><br><span class=\"line\"> * @author YHJ create at 2011-11-12 下午08:47:55</span><br><span class=\"line\"> * @FileNmae com.yhj.jvm.memory.methodArea.MethodAreaOutOfMemory.java</span><br><span class=\"line\"> */</span><br><span class=\"line\"></span><br><span class=\"line\">public class MethodAreaOutOfMemory &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * @param args</span><br><span class=\"line\">     * @Author YHJ create at 2011-11-12 下午08:47:51</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">       while(true)&#123;</span><br><span class=\"line\">           Enhancer enhancer = new Enhancer();</span><br><span class=\"line\">           enhancer.setSuperclass(TestCase.class);</span><br><span class=\"line\">           enhancer.setUseCache(false);</span><br><span class=\"line\">           enhancer.setCallback(new MethodInterceptor() &#123;</span><br><span class=\"line\">              @Override</span><br><span class=\"line\">              public Object intercept(Object arg0, Method arg1, Object[] arg2,</span><br><span class=\"line\">                  MethodProxy arg3) throws Throwable &#123;</span><br><span class=\"line\">                  return arg3.invokeSuper(arg0, arg2);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">           &#125;);</span><br><span class=\"line\">           enhancer.create();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @Described：测试用例</span><br><span class=\"line\"> * @author YHJ create at 2011-11-12 下午08:53:09</span><br><span class=\"line\"> * @FileNmae com.yhj.jvm.memory.methodArea.MethodAreaOutOfMemory.java</span><br><span class=\"line\"> */</span><br><span class=\"line\">class TestCase&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>5、直接内存溢出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.yhj.jvm.memory.directoryMemory;</span><br><span class=\"line\">import java.lang.reflect.Field;</span><br><span class=\"line\">import sun.misc.Unsafe;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @Described：直接内存溢出测试</span><br><span class=\"line\"> * @VM args: -Xmx20M -XX:MaxDirectMemorySize=10M</span><br><span class=\"line\"> * @author YHJ create at 2011-11-12 下午09:06:10</span><br><span class=\"line\"> * @FileNmae </span><br><span class=\"line\"> */</span><br><span class=\"line\">public class DirectoryMemoryOutOfmemory &#123;</span><br><span class=\"line\">    private static final int ONE_MB = 1024*1024;</span><br><span class=\"line\">    private static int count = 1;</span><br><span class=\"line\">    </span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * @param args</span><br><span class=\"line\">     * @Author YHJ create at 2011-11-12 下午09:05:54</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">       try &#123;</span><br><span class=\"line\">           Field field = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</span><br><span class=\"line\">           field.setAccessible(true);</span><br><span class=\"line\">           Unsafe unsafe = (Unsafe) field.get(null);</span><br><span class=\"line\">           while (true) &#123;</span><br><span class=\"line\">              unsafe.allocateMemory(ONE_MB);</span><br><span class=\"line\">              count++;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125; catch (Exception e) &#123;</span><br><span class=\"line\">           System.out.println(&quot;Exception:instance created &quot;+count);</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125; catch (Error e) &#123;</span><br><span class=\"line\">           System.out.println(&quot;Error:instance created &quot;+count);</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"内存\"><a href=\"#内存\" class=\"headerlink\" title=\"内存\"></a>内存</h2><p>我们知道，计算机CPU和内存的交互是最频繁的，内存是我们的高速缓存区，用户磁盘和CPU的交互，而CPU运转速度越来越快，磁盘远远跟不上CPU的读写速度，才设计了内存，用户缓冲用户IO等待导致CPU的等待成本，但是随着CPU的发展，内存的读写速度也远远跟不上CPU的读写速度，因此，为了解决这一纠纷，CPU厂商在每颗CPU上加入了高速缓存，用来缓解这种症状，因此，现在CPU同内存交互就变成了下面的样子。</p>\n<p><img src=\"../img/cpu.jpg\"> </p>\n<p>同样，根据摩尔定律，我们知道单核CPU的主频不可能无限制的增长，要想很多的提升新能，需要多个处理器协同工作， Intel总裁的贝瑞特单膝下跪事件标志着多核时代的到来。</p>\n<p>基于高速缓存的存储交互很好的解决了处理器与内存之间的矛盾，也引入了新的问题：缓存一致性问题。在多处理器系统中，每个处理器有自己的高速缓存，而他们又共享同一块内存（下文成主存，main memory 主要内存），当多个处理器运算都涉及到同一块内存区域的时候，就有可能发生缓存不一致的现象。为了解决这一问题，需要各个处理器运行时都遵循一些协议，在运行时需要将这些协议保证数据的一致性。这类协议包括MSI、MESI、MOSI、Synapse、Firely、DragonProtocol等。如下图所示</p>\n<p><img src=\"../img/memory.jpg\"></p>\n<p>Java虚拟机内存模型中定义的访问操作与物理计算机处理的基本一致！<br><img src=\"../img/java-memory.jpg\"></p>\n<p>Java中通过多线程机制使得多个任务同时执行处理，所有的线程共享JVM内存区域main memory，而每个线程又单独的有自己的工作内存，当线程与内存区域进行交互时，数据从主存拷贝到工作内存，进而交由线程处理（操作码+操作数）。更多信息我们会在后面的《深入JVM—JVM类执行机制中详细解说》。<br>在之前，我们也已经提到，JVM的逻辑内存模型如下：<br><img src=\"../img/java-memory2.jpg\"></p>\n<p>我们现在来逐个的看下每个到底是做什么的！</p>\n<p>1、程序计数器</p>\n<p>程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。由于Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。如果线程正在执行的是一个Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie 方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在Java 虚拟机规范中没有规定任何OutOfMemoryError 情况的区域。</p>\n<p>2、Java 虚拟机栈</p>\n<p>与程序计数器一样，Java 虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame ①）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。经常有人把Java 内存区分为堆内存（Heap）和栈内存（Stack），这种分法比较粗糙，Java 内存区域的划分实际上远比这复杂。这种划分方式的流行只能说明大多数程序员最关注的、与对象内存分配关系最密切的内存区域是这两块。其中所指的“堆”在后面会专门讲述，而所指的“栈”就是现在讲的虚拟机栈，或者说是虚拟机栈中的局部变量表部分。局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress 类型（指向了一条字节码指令的地址）。其中64 位长度的long 和double 类型的数据会占用2 个局部变量空间（Slot），其余的数据类型只占用1 个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。在Java 虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError 异常；如果虚拟机栈可以动态扩展（当前大部分的Java 虚拟机都可动态扩展，只不过Java 虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError 异常。</p>\n<p>3、本地方法栈</p>\n<p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native 方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot 虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError 和OutOfMemoryError异常。</p>\n<p>4、Java 堆</p>\n<p>对于大多数应用来说，Java 堆（Java Heap）是Java 虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java 虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配①，但是随着JIT 编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换②优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。Java 堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC 堆”（GarbageCollected Heap，幸好国内没翻译成“垃圾堆”）。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java 堆中还可以细分为：新生代和老年代；再细致一点的有Eden 空间、From Survivor 空间、To Survivor 空间等。如果从内存分配的角度看，线程共享的Java 堆中可能划分出多个线程私有的分配缓冲区（Thread LocalAllocation Buffer，TLAB）。不过，无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。在本章中，我们仅仅针对内存区域的作用进行讨论，Java 堆中的上述各个区域的分配和回收等细节将会是下一章的主题。根据Java 虚拟机规范的规定，Java 堆可以处于物理上不连续的内存空间中，只逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms 控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError 异常。</p>\n<p>4、方法区</p>\n<p>方法区（Method Area）与Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java 堆区分开来。对于习惯在HotSpot 虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot 虚拟机的设计团队选择把GC 分代收集扩展至方法区，或者说使用永久代来实现方法区而已。对于其他虚拟机（如BEA JRockit、IBM J9 等）来说是不存在永久代的概念的。即使是HotSpot 虚拟机本身，根据官方发布的路线图信息，现在也有放弃永久代并“搬家”至Native Memory 来实现方法区的规划了。Java 虚拟机规范对这个区域的限制非常宽松，除了和Java 堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。在Sun 公司的BUG 列表中，曾出现过的若干个严重的BUG 就是由于低版本的HotSpot 虚拟机对此区域未完全回收而导致内存泄漏。根据Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError 异常。</p>\n<p>5、运行时常量池</p>\n<p>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（Constant PoolTable），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。Java 虚拟机对Class 文件的每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。但对于运行时常量池，Java 虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除了保存Class 文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中①。运行时常量池相对于Class 文件常量池的另外一个重要特征是具备动态性，Java 语言并不要求常量一定只能在编译期产生，也就是并非预置入Class 文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String 类的intern() 方法。既然运行时常量池是方法区的一部分，自然会受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError 异常</p>\n<p>6、直接内存</p>\n<p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError 异常出现，所以我们放到这里一起讲解。在JDK 1.4 中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O 方式，它可以使用Native 函数库直接分配堆外内存，然后通过一个存储在Java 堆里面的DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java 堆和Native 堆中来回复制数据。显然，本机直接内存的分配不会受到Java 堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括RAM 及SWAP 区或者分页文件）的大小及处理器寻址空间的限制。服务器管理员配置虚拟机参数时，一般会根据实际内存设置-Xmx等参数信息，但经常会忽略掉直接内存，使得各个内存区域的总和大于物理内存限制（包括物理上的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。</p>\n<p>逻辑内存模型我们已经看到了，那当我们建立一个对象的时候是怎么进行访问的呢？在Java 语言中，对象访问是如何进行的？对象访问在Java 语言中无处不在，是最普通的程序行为，但即使是最简单的访问，也会却涉及Java 栈、Java 堆、方法区这三个最重要内存区<br>域之间的关联关系，如下面的这句代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object obj = new Object();</span><br></pre></td></tr></table></figure>\n<p>假设这句代码出现在方法体中，那“Object obj”这部分的语义将会反映到Java 栈的本地变量表中，作为一个reference 类型数据出现。而“new Object()”这部分的语义将会反映到Java 堆中，形成一块存储了Object 类型所有实例数据值（Instance Data，对象中各个实例字段的数据）的结构化内存，根据具体类型以及虚拟机实现的对象内存布局（Object Memory Layout）的不同，这块内存的长度是不固定的。另外，在Java 堆中还必须包含能查找到此对象类型数据（如对象类型、父类、实现的接口、方法等）的地址信息，这些类型数据则存储在方法区中。由于reference 类型在Java 虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到Java 堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：使用句柄和直接指针。如果使用句柄访问方式，Java 堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息，如下图所示。<br><img src=\"../img/java-stack.jpg\"></p>\n<p>如果使用直接指针访问方式，Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference 中直接存储的就是对象地址，如下图所示</p>\n<p><img src=\"../img/java-stack2.jpg\"></p>\n<p>这两种对象的访问方式各有优势，使用句柄访问方式的最大好处就是reference 中存<br>储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference 本身不需要被修改。使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java 中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。就本书讨论的主要虚拟机Sun HotSpot 而言，它是使用第二种方式进行对象访问的，但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见。下面我们来看几个示例</p>\n<p>1、Java 堆溢出</p>\n<p>下面的程中我们限制Java 堆的大小为20MB，不可扩展（将堆的最小值-Xms 参数与最大值-Xmx 参数设置为一样即可避免堆自动扩展），通过参数-XX:+HeapDumpOnOutOfMemoryError 可以让虚拟机在出现内存溢出异常时Dump 出当前的内存堆转储快照以便事后进行分析。<br>参数设置如下<br><img src=\"../img/eclipse-conf.jpg\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.yhj.jvm.memory.heap;</span><br><span class=\"line\">import java.util.ArrayList;</span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @Described：堆溢出测试</span><br><span class=\"line\"> * @VM args:-verbose:gc -Xms20M -Xmx20M -XX:+PrintGCDetails</span><br><span class=\"line\"> * @author YHJ create at 2011-11-12 下午07:52:22</span><br><span class=\"line\"> * @FileNmae com.yhj.jvm.memory.heap.HeapOutOfMemory.java</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class HeapOutOfMemory &#123;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * @param args</span><br><span class=\"line\">     * @Author YHJ create at 2011-11-12 下午07:52:18</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">       List&lt;TestCase&gt; cases = new ArrayList&lt;TestCase&gt;();</span><br><span class=\"line\">       while(true)&#123;</span><br><span class=\"line\">           cases.add(new TestCase());</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @Described：测试用例</span><br><span class=\"line\"> * @author YHJ create at 2011-11-12 下午07:55:50</span><br><span class=\"line\"> * @FileNmae com.yhj.jvm.memory.heap.HeapOutOfMemory.java</span><br><span class=\"line\"> */</span><br><span class=\"line\">class TestCase&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Java 堆内存的OutOfMemoryError异常是实际应用中最常见的内存溢出异常情况。出现Java 堆内<br>存溢出时，异常堆栈信息“java.lang.OutOfMemoryError”会跟着进一步提示“Java heap</p>\n<p>space”。</p>\n<p>要解决这个区域的异常，一般的手段是首先通过内存映像分析工具（如Eclipse</p>\n<p>Memory Analyzer）对dump 出来的堆转储快照进行分析，重点是确认内存中的对象是</p>\n<p>否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢</p>\n<p>出（Memory Overflow）。图2-5 显示了使用Eclipse Memory Analyzer 打开的堆转储快</p>\n<p>照文件。</p>\n<p>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots 的引用链。于是就</p>\n<p>能找到泄漏对象是通过怎样的路径与GC Roots 相关联并导致垃圾收集器无法自动回收</p>\n<p>它们的。掌握了泄漏对象的类型信息，以及GC Roots 引用链的信息，就可以比较准确</p>\n<p>地定位出泄漏代码的位置。</p>\n<p>如果不存在泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查</p>\n<p>虚拟机的堆参数（-Xmx 与-Xms），与机器物理内存对比看是否还可以调大，从代码上</p>\n<p>检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期</p>\n<p>的内存消耗。</p>\n<p>以上是处理Java 堆内存问题的简略思路，处理这些问题所需要的知识、工具与经验</p>\n<p>在后面的几次分享中我会做一些额外的分析。</p>\n<p>2、java栈溢出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.yhj.jvm.memory.stack;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @Described：栈层级不足探究</span><br><span class=\"line\"> * @VM args:-Xss128k</span><br><span class=\"line\"> * @author YHJ create at 2011-11-12 下午08:19:28</span><br><span class=\"line\"> * @FileNmae com.yhj.jvm.memory.stack.StackOverFlow.java</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class StackOverFlow &#123;</span><br><span class=\"line\">    private int i ;</span><br><span class=\"line\">    public void plus() &#123;</span><br><span class=\"line\">       i++;</span><br><span class=\"line\">       plus();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * @param args</span><br><span class=\"line\">     * @Author YHJ create at 2011-11-12 下午08:19:21</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">       StackOverFlow stackOverFlow = new StackOverFlow();</span><br><span class=\"line\">       try &#123;</span><br><span class=\"line\">           stackOverFlow.plus();</span><br><span class=\"line\">       &#125; catch (Exception e) &#123;</span><br><span class=\"line\">           System.out.println(&quot;Exception:stack length:&quot;+stackOverFlow.i);</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125; catch (Error e) &#123;</span><br><span class=\"line\">           System.out.println(&quot;Error:stack length:&quot;+stackOverFlow.i);</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>3、常量池溢出（常量池都有哪些信息，我们在后续的JVM类文件结构中详细描述）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.yhj.jvm.memory.constant;</span><br><span class=\"line\">import java.util.ArrayList;</span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @Described：常量池内存溢出探究</span><br><span class=\"line\"> * @VM args : -XX:PermSize=10M -XX:MaxPermSize=10M</span><br><span class=\"line\"> * @author YHJ create at 2011-10-30 下午04:28:30</span><br><span class=\"line\"> * @FileNmae com.yhj.jvm.memory.constant.ConstantOutOfMemory.java</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class ConstantOutOfMemory &#123;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * @param args</span><br><span class=\"line\">     * @throws Exception</span><br><span class=\"line\">     * @Author YHJ create at 2011-10-30 下午04:28:25</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static void main(String[] args) throws Exception &#123;</span><br><span class=\"line\">       try &#123;</span><br><span class=\"line\">           List&lt;String&gt; strings = new ArrayList&lt;String&gt;();</span><br><span class=\"line\">           int i = 0;</span><br><span class=\"line\">           while(true)&#123;</span><br><span class=\"line\">              strings.add(String.valueOf(i++).intern());</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125; catch (Exception e) &#123;</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">           throw e;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>4、方法去溢出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.yhj.jvm.memory.methodArea;</span><br><span class=\"line\">import java.lang.reflect.Method;</span><br><span class=\"line\">import net.sf.cglib.proxy.Enhancer;</span><br><span class=\"line\">import net.sf.cglib.proxy.MethodInterceptor;</span><br><span class=\"line\">import net.sf.cglib.proxy.MethodProxy;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @Described：方法区溢出测试</span><br><span class=\"line\"> * 使用技术 CBlib</span><br><span class=\"line\"> * @VM args : -XX:PermSize=10M -XX:MaxPermSize=10M</span><br><span class=\"line\"> * @author YHJ create at 2011-11-12 下午08:47:55</span><br><span class=\"line\"> * @FileNmae com.yhj.jvm.memory.methodArea.MethodAreaOutOfMemory.java</span><br><span class=\"line\"> */</span><br><span class=\"line\"></span><br><span class=\"line\">public class MethodAreaOutOfMemory &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * @param args</span><br><span class=\"line\">     * @Author YHJ create at 2011-11-12 下午08:47:51</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">       while(true)&#123;</span><br><span class=\"line\">           Enhancer enhancer = new Enhancer();</span><br><span class=\"line\">           enhancer.setSuperclass(TestCase.class);</span><br><span class=\"line\">           enhancer.setUseCache(false);</span><br><span class=\"line\">           enhancer.setCallback(new MethodInterceptor() &#123;</span><br><span class=\"line\">              @Override</span><br><span class=\"line\">              public Object intercept(Object arg0, Method arg1, Object[] arg2,</span><br><span class=\"line\">                  MethodProxy arg3) throws Throwable &#123;</span><br><span class=\"line\">                  return arg3.invokeSuper(arg0, arg2);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">           &#125;);</span><br><span class=\"line\">           enhancer.create();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @Described：测试用例</span><br><span class=\"line\"> * @author YHJ create at 2011-11-12 下午08:53:09</span><br><span class=\"line\"> * @FileNmae com.yhj.jvm.memory.methodArea.MethodAreaOutOfMemory.java</span><br><span class=\"line\"> */</span><br><span class=\"line\">class TestCase&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>5、直接内存溢出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.yhj.jvm.memory.directoryMemory;</span><br><span class=\"line\">import java.lang.reflect.Field;</span><br><span class=\"line\">import sun.misc.Unsafe;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @Described：直接内存溢出测试</span><br><span class=\"line\"> * @VM args: -Xmx20M -XX:MaxDirectMemorySize=10M</span><br><span class=\"line\"> * @author YHJ create at 2011-11-12 下午09:06:10</span><br><span class=\"line\"> * @FileNmae </span><br><span class=\"line\"> */</span><br><span class=\"line\">public class DirectoryMemoryOutOfmemory &#123;</span><br><span class=\"line\">    private static final int ONE_MB = 1024*1024;</span><br><span class=\"line\">    private static int count = 1;</span><br><span class=\"line\">    </span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * @param args</span><br><span class=\"line\">     * @Author YHJ create at 2011-11-12 下午09:05:54</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">       try &#123;</span><br><span class=\"line\">           Field field = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</span><br><span class=\"line\">           field.setAccessible(true);</span><br><span class=\"line\">           Unsafe unsafe = (Unsafe) field.get(null);</span><br><span class=\"line\">           while (true) &#123;</span><br><span class=\"line\">              unsafe.allocateMemory(ONE_MB);</span><br><span class=\"line\">              count++;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125; catch (Exception e) &#123;</span><br><span class=\"line\">           System.out.println(&quot;Exception:instance created &quot;+count);</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125; catch (Error e) &#123;</span><br><span class=\"line\">           System.out.println(&quot;Error:instance created &quot;+count);</span><br><span class=\"line\">           e.printStackTrace();</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjtf8e1cn0003v3b8re7tnbvd","tag_id":"cjtf8e1cr0006v3b8gj8fnkvv","_id":"cjtf8e1cw000bv3b8hu6j6gqg"},{"post_id":"cjtf8e1cn0003v3b8re7tnbvd","tag_id":"cjtf8e1cv0008v3b85lhlpgwe","_id":"cjtf8e1cw000cv3b8r8w1fhjx"},{"post_id":"cjtf8e1cn0003v3b8re7tnbvd","tag_id":"cjtf8e1cv0009v3b8mehhopg8","_id":"cjtf8e1cw000ev3b8xhohawz2"},{"post_id":"cjtf8e1ct0007v3b8rjj2qyde","tag_id":"cjtf8e1cv000av3b88yxyzczk","_id":"cjtf8e1cw000fv3b8jluo31kh"},{"post_id":"cjtf8e1ct0007v3b8rjj2qyde","tag_id":"cjtf8e1cw000dv3b86qn97odk","_id":"cjtf8e1cw000gv3b8q8w139s9"},{"post_id":"cjtf8e1cx000hv3b8aik3rmm7","tag_id":"cjtf8e1d1000iv3b8cxo97zlb","_id":"cjtf8e1d1000kv3b827fgqsm9"},{"post_id":"cjtf8e1cx000hv3b8aik3rmm7","tag_id":"cjtf8e1d1000jv3b87ykjuf2a","_id":"cjtf8e1d1000lv3b87td3c0o1"}],"Tag":[{"name":"BlueLake","_id":"cjtf8e1cr0006v3b8gj8fnkvv"},{"name":"博客主题","_id":"cjtf8e1cv0008v3b85lhlpgwe"},{"name":"blogTheme","_id":"cjtf8e1cv0009v3b8mehhopg8"},{"name":"Jvm优化","_id":"cjtf8e1cv000av3b88yxyzczk"},{"name":"Java优化","_id":"cjtf8e1cw000dv3b86qn97odk"},{"name":"Jvm","_id":"cjtf8e1d1000iv3b8cxo97zlb"},{"name":"原理","_id":"cjtf8e1d1000jv3b87ykjuf2a"}]}}